<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: algorithm - lawilet&#039;s website</title><meta property="og:type" content="blog"><meta property="og:title" content="lawilet&#039;s website"><meta property="og:url" content="http://law-liet.com/"><meta property="og:site_name" content="lawilet&#039;s website"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://law-liet.com/img/og_image.png"><meta property="article:author" content="lawiet019"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://law-liet.com"},"headline":"lawilet's website","image":["http://law-liet.com/img/og_image.png"],"author":{"@type":"Person","name":"lawiet019"},"description":""}</script><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.png" alt="lawilet&#039;s website" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lawiet019"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">algorithm</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-12-29T15:37:00.000Z" title="2020-12-29T15:37:00.000Z">2020-12-29</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">6 minutes read (About 935 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/29/shortest-path-algorithm/">shortest path algorithm</a></h1><div class="content"><p>When we want to get the shortest from source node to dest node.<br>Here are some ways and corresponding application scenarios.</p>
<h2 id="dijkstra-algorithm"><a href="#dijkstra-algorithm" class="headerlink" title="dijkstra algorithm"></a>dijkstra algorithm</h2><p>-Suitable for:<br>1.single source node shortest path<br>2.the weight cannot be negative </p>
<ul>
<li>implemention<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">()</span>:</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vertices)</span>:</span> </span><br><span class="line">        self.V = vertices </span><br><span class="line">        self.graph = [[<span class="number">0</span> <span class="keyword">for</span> column <span class="keyword">in</span> range(vertices)]  </span><br><span class="line">                    <span class="keyword">for</span> row <span class="keyword">in</span> range(vertices)] </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printSolution</span><span class="params">(self, dist)</span>:</span> </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Vertex tDistance from Source"</span>) </span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> range(self.V): </span><br><span class="line">            <span class="keyword">print</span> (node, <span class="string">"t"</span>, dist[node]) </span><br><span class="line"></span><br><span class="line">    <span class="comment"># A utility function to find the vertex with  </span></span><br><span class="line">    <span class="comment"># minimum distance value, from the set of vertices  </span></span><br><span class="line">    <span class="comment"># not yet included in shortest path tree </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, dist, sptSet)</span>:</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Initilaize minimum distance for next node </span></span><br><span class="line">        min = sys.maxsize </span><br><span class="line"></span><br><span class="line">        <span class="comment"># Search not nearest vertex not in the  </span></span><br><span class="line">        <span class="comment"># shortest path tree </span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(self.V): </span><br><span class="line">            <span class="keyword">if</span> dist[v] &lt; min <span class="keyword">and</span> sptSet[v] == <span class="literal">False</span>: </span><br><span class="line">                min = dist[v] </span><br><span class="line">                min_index = v </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_index </span><br><span class="line"></span><br><span class="line">    <span class="comment"># Funtion that implements Dijkstra's single source  </span></span><br><span class="line">    <span class="comment"># shortest path algorithm for a graph represented  </span></span><br><span class="line">    <span class="comment"># using adjacency matrix representation </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(self, src)</span>:</span> </span><br><span class="line"></span><br><span class="line">        dist = [sys.maxsize] * self.V </span><br><span class="line">        dist[src] = <span class="number">0</span></span><br><span class="line">        sptSet = [<span class="literal">False</span>] * self.V </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cout <span class="keyword">in</span> range(self.V): </span><br><span class="line"></span><br><span class="line">            <span class="comment"># Pick the minimum distance vertex from  </span></span><br><span class="line">            <span class="comment"># the set of vertices not yet processed.  </span></span><br><span class="line">            <span class="comment"># u is always equal to src in first iteration </span></span><br><span class="line">            u = self.minDistance(dist, sptSet) </span><br><span class="line"></span><br><span class="line">            <span class="comment"># Put the minimum distance vertex in the  </span></span><br><span class="line">            <span class="comment"># shotest path tree </span></span><br><span class="line">            sptSet[u] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Update dist value of the adjacent vertices  </span></span><br><span class="line">            <span class="comment"># of the picked vertex only if the current  </span></span><br><span class="line">            <span class="comment"># distance is greater than new distance and </span></span><br><span class="line">            <span class="comment"># the vertex in not in the shotest path tree </span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(self.V): </span><br><span class="line">                <span class="keyword">if</span> self.graph[u][v] &gt; <span class="number">0</span> <span class="keyword">and</span> \ </span><br><span class="line">                     sptSet[v] == <span class="literal">False</span> <span class="keyword">and</span> \ </span><br><span class="line">                     dist[v] &gt; dist[u] + self.graph[u][v]: </span><br><span class="line">                    dist[v] = dist[u] + self.graph[u][v] </span><br><span class="line"></span><br><span class="line">        self.printSolution(dist) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver program </span></span><br><span class="line">g = Graph(<span class="number">9</span>) </span><br><span class="line">g.graph = [[<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>], </span><br><span class="line">        [<span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">0</span>], </span><br><span class="line">        [<span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>], </span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>], </span><br><span class="line">        [<span class="number">8</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>], </span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>] </span><br><span class="line">        ]; </span><br><span class="line"></span><br><span class="line">g.dijkstra(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Floyd-algorithm"><a href="#Floyd-algorithm" class="headerlink" title="Floyd algorithm"></a>Floyd algorithm</h2></li>
<li>Suitable for </li>
</ul>
<p>1.shortest distances between every pair of vertices<br>2.cannot deal with negative cycles( because it does not have the shortest path)</p>
<ul>
<li>logic<br><a href="https://www.cnblogs.com/wangyuliang/p/9216365.html">https://www.cnblogs.com/wangyuliang/p/9216365.html</a></li>
<li>implementation</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python Program for Floyd Warshall Algorithm </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Number of vertices in the graph </span></span><br><span class="line">V = <span class="number">4</span> </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Define infinity as the large enough value. This value will be </span></span><br><span class="line"><span class="comment"># used for vertices not connected to each other </span></span><br><span class="line">INF  = <span class="number">99999</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Solves all pair shortest path via Floyd Warshall Algorithm </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floydWarshall</span><span class="params">(graph)</span>:</span> </span><br><span class="line">  </span><br><span class="line">    <span class="string">""" dist[][] will be the output matrix that will finally </span></span><br><span class="line"><span class="string">        have the shortest distances between every pair of vertices """</span></span><br><span class="line">    <span class="string">""" initializing the solution matrix same as input graph matrix </span></span><br><span class="line"><span class="string">    OR we can say that the initial values of shortest distances </span></span><br><span class="line"><span class="string">    are based on shortest paths considering no  </span></span><br><span class="line"><span class="string">    intermediate vertices """</span></span><br><span class="line">    dist = map(<span class="keyword">lambda</span> i : map(<span class="keyword">lambda</span> j : j , i) , graph) </span><br><span class="line">      </span><br><span class="line">    <span class="string">""" Add all vertices one by one to the set of intermediate </span></span><br><span class="line"><span class="string">     vertices. </span></span><br><span class="line"><span class="string">     ---&gt; Before start of an iteration, we have shortest distances </span></span><br><span class="line"><span class="string">     between all pairs of vertices such that the shortest </span></span><br><span class="line"><span class="string">     distances consider only the vertices in the set  </span></span><br><span class="line"><span class="string">    &#123;0, 1, 2, .. k-1&#125; as intermediate vertices. </span></span><br><span class="line"><span class="string">      ----&gt; After the end of a iteration, vertex no. k is </span></span><br><span class="line"><span class="string">     added to the set of intermediate vertices and the  </span></span><br><span class="line"><span class="string">    set becomes &#123;0, 1, 2, .. k&#125; </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(V): </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># pick all vertices as source one by one </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(V): </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># Pick all vertices as destination for the </span></span><br><span class="line">            <span class="comment"># above picked source </span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(V): </span><br><span class="line">  </span><br><span class="line">                <span class="comment"># If vertex k is on the shortest path from  </span></span><br><span class="line">                <span class="comment"># i to j, then update the value of dist[i][j] </span></span><br><span class="line">                dist[i][j] = min(dist[i][j] , </span><br><span class="line">                                  dist[i][k]+ dist[k][j] </span><br><span class="line">                                ) </span><br><span class="line">    printSolution(dist) </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># A utility function to print the solution </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printSolution</span><span class="params">(dist)</span>:</span> </span><br><span class="line">    print(<span class="string">"Following matrix shows the shortest distances\ </span></span><br><span class="line"><span class="string"> between every pair of vertices"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(V): </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V): </span><br><span class="line">            <span class="keyword">if</span>(dist[i][j] == INF): </span><br><span class="line">                print(<span class="string">"%7s"</span> %(<span class="string">"INF"</span>))</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                print(<span class="string">"%7d\t"</span> %(dist[i][j])) </span><br><span class="line">            <span class="keyword">if</span> j == V<span class="number">-1</span>: </span><br><span class="line">                print(<span class="string">""</span>)</span><br><span class="line"><span class="comment"># Driver program to test the above program </span></span><br><span class="line"><span class="comment"># Let us create the following weighted graph </span></span><br><span class="line">  <span class="string">""" </span></span><br><span class="line"><span class="string">              10 </span></span><br><span class="line"><span class="string">         (0)-------&gt;(3) </span></span><br><span class="line"><span class="string">          |         /|\ </span></span><br><span class="line"><span class="string">        5 |          | </span></span><br><span class="line"><span class="string">          |          | 1 </span></span><br><span class="line"><span class="string">         \|/         | </span></span><br><span class="line"><span class="string">         (1)-------&gt;(2) </span></span><br><span class="line"><span class="string">              3           </span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">graph = [[<span class="number">0</span>,<span class="number">5</span>,INF,<span class="number">10</span>], </span><br><span class="line">             [INF,<span class="number">0</span>,<span class="number">3</span>,INF], </span><br><span class="line">             [INF, INF, <span class="number">0</span>,   <span class="number">1</span>], </span><br><span class="line">             [INF, INF, INF, <span class="number">0</span>] </span><br><span class="line">        ] </span><br><span class="line"><span class="comment"># Print the solution </span></span><br><span class="line">floydWarshall(graph); </span><br><span class="line"><span class="comment"># This code is contributed by Nikhil Kumar Singh(nickzuck_007)</span></span><br></pre></td></tr></table></figure>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><ul>
<li>Suitable for :</li>
</ul>
<ol>
<li>graph with negative cycles<br>2.details<br><a href="https://zhuanlan.zhihu.com/p/58727559">https://zhuanlan.zhihu.com/p/58727559</a></li>
<li>implementation</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python3 implementation of SPFA </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque </span><br><span class="line">   </span><br><span class="line"><span class="comment"># Graph is stored as vector of vector of pairs </span></span><br><span class="line"><span class="comment"># first element of pair store vertex </span></span><br><span class="line"><span class="comment"># second element of pair store weight </span></span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100000</span>)] </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Function to add edges in the graph </span></span><br><span class="line"><span class="comment"># connecting a pair of vertex(frm) and weight </span></span><br><span class="line"><span class="comment"># to another vertex(to) in graph </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addEdge</span><span class="params">(frm, to, weight)</span>:</span> </span><br><span class="line">  </span><br><span class="line">    graph[frm].append([to, weight]) </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Function to prshortest distance from source </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_distance</span><span class="params">(d, V)</span>:</span> </span><br><span class="line">    print(<span class="string">"Vertex"</span>,<span class="string">"\t"</span>,<span class="string">"Distance from source"</span>) </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, V + <span class="number">1</span>): </span><br><span class="line">        print(i,<span class="string">"\t"</span>,d[i]) </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Function to compute the SPF algorithm </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestPathFaster</span><span class="params">(S, V)</span>:</span> </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Create array d to store shortest distance </span></span><br><span class="line">    d = [<span class="number">10</span>**<span class="number">9</span>]*(V + <span class="number">1</span>) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Boolean array to check if vertex </span></span><br><span class="line">    <span class="comment"># is present in queue or not </span></span><br><span class="line">    inQueue = [<span class="literal">False</span>]*(V + <span class="number">1</span>) </span><br><span class="line">  </span><br><span class="line">    d[S] = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">    q = deque() </span><br><span class="line">    q.append(S) </span><br><span class="line">    inQueue[S] = <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (len(q) &gt; <span class="number">0</span>): </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Take the front vertex from Queue </span></span><br><span class="line">        u = q.popleft() </span><br><span class="line">        inQueue[u] = <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># Relaxing all the adjacent edges of </span></span><br><span class="line">        <span class="comment"># vertex taken from the Queue </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph[u])): </span><br><span class="line">  </span><br><span class="line">            v = graph[u][i][<span class="number">0</span>] </span><br><span class="line">            weight = graph[u][i][<span class="number">1</span>] </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (d[v] &gt; d[u] + weight): </span><br><span class="line">                d[v] = d[u] + weight </span><br><span class="line">  </span><br><span class="line">                <span class="comment"># Check if vertex v is in Queue or not </span></span><br><span class="line">                <span class="comment"># if not then append it into the Queue </span></span><br><span class="line">                <span class="keyword">if</span> (inQueue[v] == <span class="literal">False</span>): </span><br><span class="line">                    q.append(v) </span><br><span class="line">                    inQueue[v] = <span class="literal">True</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Print the result </span></span><br><span class="line">    print_distance(d, V) </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Driver code </span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">    V = <span class="number">5</span></span><br><span class="line">    S = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Connect vertex a to b with weight w </span></span><br><span class="line">    <span class="comment"># addEdge(a, b, w) </span></span><br><span class="line">  </span><br><span class="line">    addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>) </span><br><span class="line">    addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>) </span><br><span class="line">    addEdge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">-2</span>) </span><br><span class="line">    addEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>) </span><br><span class="line">    addEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>) </span><br><span class="line">    addEdge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>) </span><br><span class="line">    addEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) </span><br><span class="line">    addEdge(<span class="number">4</span>, <span class="number">5</span>, <span class="number">-3</span>) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Calling shortestPathFaster function </span></span><br><span class="line">    shortestPathFaster(S, V) </span><br><span class="line">  </span><br><span class="line"><span class="comment"># This code is contributed by mohit kumar 29</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-12-24T18:16:00.000Z" title="2020-12-24T18:16:00.000Z">2020-12-24</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">2 minutes read (About 354 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/24/check-cycles-in-directed-graph/">check cycles in directed graph</a></h1><div class="content"><p>There are two ways to check whether there are cycles in the directed graph</p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>The first methos is use DFS to check whether the node will be visited.<br>One trick is to use visited set to record all the<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkCycle1</span><span class="params">(graph)</span>:</span></span><br><span class="line">    in_degrees = dict((u,<span class="number">0</span>) <span class="keyword">for</span> u <span class="keyword">in</span> graph)   <span class="comment">#初始化所有顶点入度为0</span></span><br><span class="line">    num = len(in_degrees)</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line">            in_degrees[v] += <span class="number">1</span>    <span class="comment">#计算每个顶点的入度</span></span><br><span class="line">    start_node = [u <span class="keyword">for</span> u <span class="keyword">in</span> in_degrees <span class="keyword">if</span> in_degrees[u] == <span class="number">0</span>]   <span class="comment"># 筛选入度为0的顶点</span></span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(n,stack)</span>:</span></span><br><span class="line">        visited.add(n)</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> neighbour <span class="keyword">in</span> graph[n]:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> helper(neighbour,stack +[n]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> start_node:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="keyword">if</span> helper(node,[]):</span><br><span class="line">                print(<span class="string">"there is a cycle "</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">    print(<span class="string">"there is no cycle"</span>)</span><br><span class="line">checkCycle1(&#123;<span class="number">1</span>:[<span class="number">2</span>],<span class="number">2</span>:[<span class="number">3</span>],<span class="number">3</span>:[]&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Topological-sorting"><a href="#Topological-sorting" class="headerlink" title="Topological sorting"></a>Topological sorting</h2><p>To see the detail about Topological sorting can be seen in <a href="/2020/07/01/Topological-sorting/" title="Topological-sorting">Topological-sorting</a><br>The code can be seen as follows:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkCycle2</span><span class="params">(graph)</span>:</span></span><br><span class="line">    in_degrees = dict((u,<span class="number">0</span>) <span class="keyword">for</span> u <span class="keyword">in</span> graph)   <span class="comment">#初始化所有顶点入度为0</span></span><br><span class="line">    num = len(in_degrees)</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line">            in_degrees[v] += <span class="number">1</span>    <span class="comment">#计算每个顶点的入度</span></span><br><span class="line">    Q = [u <span class="keyword">for</span> u <span class="keyword">in</span> in_degrees <span class="keyword">if</span> in_degrees[u] == <span class="number">0</span>]   <span class="comment"># 筛选入度为0的顶点</span></span><br><span class="line">    Seq = []</span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        u = Q.pop()       <span class="comment">#默认从最后一个删除</span></span><br><span class="line">        Seq.append(u)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line">            in_degrees[v] -= <span class="number">1</span>    <span class="comment">#移除其所有出边</span></span><br><span class="line">            <span class="keyword">if</span> in_degrees[v] == <span class="number">0</span>:</span><br><span class="line">                Q.append(v)          <span class="comment">#再次筛选入度为0的顶点</span></span><br><span class="line">    <span class="keyword">if</span> len(Seq) == num:       <span class="comment">#输出的顶点数是否与图中的顶点数相等</span></span><br><span class="line">        print(<span class="string">"there is no cycle"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"there is a cycle"</span>)</span><br><span class="line">checkCycle2(&#123;<span class="number">1</span>:[<span class="number">2</span>],<span class="number">2</span>:[<span class="number">1</span>],<span class="number">3</span>:[]&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://zhuanlan.zhihu.com/p/69858335">https://zhuanlan.zhihu.com/p/69858335</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-11-27T05:09:00.000Z" title="2020-11-27T05:09:00.000Z">2020-11-27</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">a minute read (About 155 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/11/27/application-of-binary-search/">application of binary search</a></h1><div class="content"><h2 id="some-common-applications-of-binary-search"><a href="#some-common-applications-of-binary-search" class="headerlink" title="some common applications of binary search"></a>some common applications of binary search</h2><p>Since I always make mistakes on the while loop of binary search, I list the codes for common scenario.</p>
<ul>
<li>find the exact value </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(arr,target)</span>:</span></span><br><span class="line">    arr.sort()</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(arr)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) //<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; target:</span><br><span class="line">            right = mid <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>find the closet value </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findClosetElement</span><span class="params">(arr,target)</span>:</span></span><br><span class="line">    arr.sort()</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(arr)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> target &gt;=arr[<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">return</span>  right</span><br><span class="line">    <span class="keyword">if</span> target &lt;= arr[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">while</span> right - left &gt;<span class="number">1</span>:</span><br><span class="line">        mid = (right + left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid] &gt; target:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid</span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">if</span> abs(arr[left] - target) &lt; abs(arr[right] - target) <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure>
<ul>
<li>find the maximum value less than the target</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMax</span><span class="params">(arr,target)</span>:</span></span><br><span class="line">    arr.sort()</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(arr) <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left + right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> arr[mid]&gt;= target:</span><br><span class="line">            right = mid <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left  = mid +<span class="number">1</span></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-10-11T20:02:00.000Z" title="2020-10-11T20:02:00.000Z">2020-10-11</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">5 minutes read (About 773 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/11/prefix-infix-and-postfix/">prefix,infix and postfix</a></h1><div class="content"><h3 id="1-what-is-prefix-infix-and-postfix"><a href="#1-what-is-prefix-infix-and-postfix" class="headerlink" title="1. what is prefix,infix and postfix"></a>1. what is prefix,infix and postfix</h3><ul>
<li><strong>Infix notation:</strong> <code>X + Y</code><br>Operators are written in-between their operands. This is the usual way we write expressions. An expression such as <code>A * ( B + C ) / D</code> is usually taken to mean something like: “First add B and C together, then multiply the result by A, then divide by D to give the final answer.”</li>
<li><strong> Postfix notation</strong> (also known as “Reverse Polish notation”): <code>X Y +</code><br>Operators are written after their operands.The infix expression given above is equivalent to <code>A B C + * D /</code></li>
<li><strong>Prefix notation </strong>(also known as “Polish notation”): <code>+ X Y</code><br>Operators are written before their operands. The expressions given above are equivalent to / * A + B C D`</li>
</ul>
<p>And we use infix in real life but use prefix for computers</p>
<h3 id="2-how-to-compute-the-result-of-prefix"><a href="#2-how-to-compute-the-result-of-prefix" class="headerlink" title="2. how to compute the result of  prefix"></a>2. how to compute the result of  prefix</h3><ul>
<li>Steps:<br>Traverse the expression from left to right:<ul>
<li>If it is a number, press num_ Stack.</li>
<li>If it is an operator, take out num_ The first two elements in the stack, the second is the operands on the left side of the expression, calculate the value of the expression, and press the evaluation result into num_Stack.</li>
</ul>
</li>
<li>example:<br>Leetcode 150. Evaluate Reverse Polish Notation<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">      stack = []</span><br><span class="line">      <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">          <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>, <span class="string">"/"</span>]:</span><br><span class="line">              stack.append(int(t))</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              r, l = stack.pop(), stack.pop()</span><br><span class="line">              <span class="keyword">if</span> t == <span class="string">"+"</span>:</span><br><span class="line">                  stack.append(l+r)</span><br><span class="line">              <span class="keyword">elif</span> t == <span class="string">"-"</span>:</span><br><span class="line">                  stack.append(l-r)</span><br><span class="line">              <span class="keyword">elif</span> t == <span class="string">"*"</span>:</span><br><span class="line">                  stack.append(l*r)</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  <span class="comment"># here take care of the case like "1/-22",</span></span><br><span class="line">                  <span class="comment"># in Python 2.x, it returns -1, while in</span></span><br><span class="line">                  <span class="comment"># Leetcode it should return 0</span></span><br><span class="line">                  <span class="keyword">if</span> l*r &lt; <span class="number">0</span> <span class="keyword">and</span> l % r != <span class="number">0</span>:</span><br><span class="line">                      stack.append(l//r+<span class="number">1</span>)</span><br><span class="line">                  <span class="keyword">else</span>:</span><br><span class="line">                      stack.append(l//r)</span><br><span class="line">      <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-convert-prefix-to-infix"><a href="#3-convert-prefix-to-infix" class="headerlink" title="3. convert prefix to infix"></a>3. convert prefix to infix</h3><ul>
<li>steps:</li>
</ul>
<ol>
<li>If it is a number, add it to output directly.</li>
<li>If it is an operator, compare the toppest operator with Op_Stack The priority of the operator in the stack, if the priority is greater than that in  Op_Stack, push  it into Op_ Stack<br>Otherwise, pop all operators in the Op_Stack whose priority is greater than or equal to the priority of the operator are added to the output, and then push this operator into Op_ Stack</li>
<li>If it is <code>(</code> , press Op_ Stack</li>
<li>If it is a <code>)</code>, pop  all operators in front of the left bracket in the stack a to the output<br>Repeat the above steps.</li>
<li>It will pop all the element in the stack in order<br>The code can be seen as follows:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">priority</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> z <span class="keyword">in</span> [<span class="string">'×'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> z <span class="keyword">in</span> [<span class="string">'+'</span>, <span class="string">'-'</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in2post</span><span class="params">(expr)</span>:</span></span><br><span class="line">    <span class="string">""" :param expr: 前缀表达式</span></span><br><span class="line"><span class="string">        :return: 后缀表达式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Example：</span></span><br><span class="line"><span class="string">            "1+((2+3)×4)-5"</span></span><br><span class="line"><span class="string">            "1 2 3 + 4 × + 5 -"</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    stack = []  <span class="comment"># 存储栈</span></span><br><span class="line">    post = []  <span class="comment"># 后缀表达式存储</span></span><br><span class="line">    <span class="keyword">for</span> z <span class="keyword">in</span> expr:</span><br><span class="line">        <span class="keyword">if</span> z <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'×'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'('</span>, <span class="string">')'</span>]:  <span class="comment"># 字符直接输出</span></span><br><span class="line">            post.append(z)</span><br><span class="line">            print(<span class="number">1</span>, post)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> z != <span class="string">')'</span> <span class="keyword">and</span> (<span class="keyword">not</span> stack <span class="keyword">or</span> z == <span class="string">'('</span> <span class="keyword">or</span> stack[<span class="number">-1</span>] == <span class="string">'('</span></span><br><span class="line">                             <span class="keyword">or</span> priority(z) &gt; priority(stack[<span class="number">-1</span>])):  <span class="comment"># stack 不空；栈顶为（；优先级大于</span></span><br><span class="line">                stack.append(z)     <span class="comment"># 运算符入栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> z == <span class="string">')'</span>:  <span class="comment"># 右括号出栈</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    x = stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> x != <span class="string">'('</span>:</span><br><span class="line">                        post.append(x)</span><br><span class="line">                        print(<span class="number">2</span>, post)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:   <span class="comment"># 比较运算符优先级，看是否入栈出栈</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] != <span class="string">'('</span> <span class="keyword">and</span> priority(z) &lt;= priority(stack[<span class="number">-1</span>]):</span><br><span class="line">                        post.append(stack.pop())</span><br><span class="line">                        print(<span class="number">3</span>, post)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        stack.append(z)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">while</span> stack:    <span class="comment"># 还未出栈的运算符，需要加到表达式末尾</span></span><br><span class="line">        post.append(stack.pop())</span><br><span class="line">    <span class="keyword">return</span> post</span><br></pre></td></tr></table></figure>
<p>And an example of application is Leetcode 224. Basic Calculator<br>Here is how I convert infix to postfix and compute it based on postfix</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        postfix = []</span><br><span class="line">        o_stack=[]</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(s):</span><br><span class="line">            c = s[index]</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = []</span><br><span class="line">                <span class="keyword">while</span> index &lt; len(s) <span class="keyword">and</span>  s[index].isdigit():</span><br><span class="line">                    num.append(s[index])</span><br><span class="line">                    index = index +<span class="number">1</span></span><br><span class="line">                postfix.append(<span class="string">""</span>.join(num))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>  c ==<span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">while</span> o_stack:</span><br><span class="line">                    cur = o_stack.pop()</span><br><span class="line">                    <span class="keyword">if</span> cur == <span class="string">'('</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    postfix.append(cur)</span><br><span class="line">             <span class="keyword">elif</span>  c ==<span class="string">"("</span> <span class="keyword">or</span> (( <span class="keyword">not</span> o_stack <span class="keyword">or</span> o_stack[<span class="number">-1</span>] == <span class="string">"("</span>) <span class="keyword">and</span> (c==<span class="string">"+"</span> <span class="keyword">or</span> c ==<span class="string">"-"</span>)):</span><br><span class="line">                 o_stack.append(c)</span><br><span class="line">             <span class="keyword">elif</span> c ==<span class="string">"+"</span> <span class="keyword">or</span> c ==<span class="string">"-"</span>:</span><br><span class="line">                 <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                     <span class="keyword">if</span> o_stack <span class="keyword">and</span> o_stack[<span class="number">-1</span>] !=<span class="string">'('</span>:</span><br><span class="line">                         postfix.append(o_stack.pop())</span><br><span class="line">                     <span class="keyword">else</span>:</span><br><span class="line">                         o_stack.append(c)</span><br><span class="line">                         <span class="keyword">break</span></span><br><span class="line">             index = index +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> o_stack:</span><br><span class="line">            postfix.append(o_stack.pop())</span><br><span class="line">        print(postfix)</span><br><span class="line">        n_stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> postfix:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                n_stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num1,num2 = int(n_stack.pop()), int(n_stack.pop())</span><br><span class="line">                <span class="keyword">if</span> c ==<span class="string">"+"</span>:</span><br><span class="line">                    n_stack.append(num1+num2)</span><br><span class="line">                <span class="keyword">elif</span> c ==<span class="string">"-"</span>:</span><br><span class="line">                    n_stack.append(num2-num1)</span><br><span class="line">        <span class="keyword">return</span> n_stack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-16T02:10:00.000Z" title="2020-08-16T02:10:00.000Z">2020-08-15</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a><span> / </span><a class="link-muted" href="/categories/technology/math/">math</a></span><span class="level-item">a minute read (About 220 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/15/Sieve-of-Eratosthenes/">Sieve of Eratosthenes</a></h1><div class="content"><p>It is the most efficient way to find all of the small primes</p>
<h2 id="steps"><a href="#steps" class="headerlink" title="steps:"></a>steps:</h2><ul>
<li>Create a list of consecutive integers from $2$ to $n$: $(2, 3, 4, …, n)$.</li>
<li>Initially, let p equal 2, the first prime number.</li>
<li>Starting from $p^2$, count up in increments of $p$ and mark each of these numbers greater than or equal to $p^2$ itself in the list. These numbers will be $p(p+1), p(p+2), p(p+3)$, etc..<br>The reason why we can start from $p^2$ rather than $2p$ is that if a number can be divided by $np ( n is less than p)$, we could find the number will be removed in previous turn. For example, we don’t need to remove 6 when $p =3$ because it is removed when p =2</li>
<li>Find the first number greater than $p$ in the list that is not marked. If there was no such number, stop. Otherwise, let $p$ now equal this number (which is the next prime), and repeat from step 3.</li>
<li>The upper limit of $p$ don’t need to be $n$ but $\sqrt{n}$</li>
</ul>
<h2 id="python-code"><a href="#python-code" class="headerlink" title="python code"></a>python code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="comment"># @param &#123;integer&#125; n</span></span><br><span class="line"><span class="comment"># @return &#123;integer&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        primes = [<span class="literal">True</span>] * n</span><br><span class="line">        primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> primes[i]:</span><br><span class="line">                primes[i * i: n: i] = [<span class="literal">False</span>] * len(primes[i * i: n: i])</span><br><span class="line">        <span class="keyword">return</span> sum(primes)</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-16T02:02:00.000Z" title="2020-08-16T02:02:00.000Z">2020-08-15</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a><span> / </span><a class="link-muted" href="/categories/technology/math/">math</a></span><span class="level-item">2 minutes read (About 255 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/15/catalan-number/">catalan number</a></h1><div class="content"><h2 id="1-formula-about-catalan-number"><a href="#1-formula-about-catalan-number" class="headerlink" title="1. formula about catalan number"></a>1. formula about catalan number</h2><p>The Catalan numbers $C_0,C_1, \ldots, C_n$,are given by the formula<br>$C_n = \frac{1}{n+1}\dbinom{2n}{n}$.<br>The proof can be found<br><a href="https://blog.csdn.net/stpeace/article/details/45938477">https://blog.csdn.net/stpeace/article/details/45938477</a> and <a href="https://brilliant.org/wiki/catalan-numbers/">https://brilliant.org/wiki/catalan-numbers/</a>.</p>
<p>And the Catalan numbers satisfy the recurrence relation<br>$C_{n+1}=C_0C_n +C_1C_{n-1}+ \ldots+ C_nC_0 $</p>
<h2 id="2-examples"><a href="#2-examples" class="headerlink" title="2.examples"></a>2.examples</h2><ul>
<li><p>Leetcode 96. Unique Binary Search Trees</p>
<p>In a BST, only the relative ordering between the elements matter. So, without any loss on generality, we can assume the distinct elements in the tree are 1, 2, 3, 4, …., n. Also, let the number of BST be represented by f(n) for n elements.</p>
<p>Now we have the multiple cases for choosing the root.</p>
<p>choose 1 as root, no element can be inserted on the left sub-tree. n-1 elements will be inserted on the right sub-tree.<br>Choose 2 as root, 1 element can be inserted on the left sub-tree. n-2 elements can be inserted on the right sub-tree.<br>Choose 3 as root, 2 element can be inserted on the left sub-tree. n-3 elements can be inserted on the right sub-tree.<br>…… Similarly, for i-th element as the root, i-1 elements can be on the left and n-i on the right.</p>
<p>These sub-trees are itself BST, thus, we can summarize the formula as:</p>
<p><code>f(n) = f(0)f(n-1) + f(1)f(n-2) + .......... + f(n-1)f(0)</code><br>The python code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">  def numTrees(self, n: int) -&gt; int:</span><br><span class="line">       return int((1&#x2F;(n+1))* math.factorial(2*n)&#x2F;math.factorial(n)&#x2F;math.factorial(n))</span><br></pre></td></tr></table></figure></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-02T01:35:00.000Z" title="2020-07-02T01:35:00.000Z">2020-07-01</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">4 minutes read (About 647 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/01/Floyd%E2%80%99s-Cycle-Finding-Algorithm/">Floyd’s Cycle-Finding Algorithm</a></h1><div class="content"><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach:"></a>Approach:</h2><p>This is the fastest method to detect cycles and has been described below:</p>
<ul>
<li>Traverse linked list using two pointers.</li>
<li>Move one pointer(slow_p) by one and another pointer(fast_p) by two. </li>
<li>If these pointers meet at the same node then there is a loop. If pointers do not meet then linked list doesn’t have a loop.<br><img src="./img/cycle_det1.jpeg" alt=""></li>
</ul>
<p><img src="/images/pasted-5.png" alt="upload successful"></p>
<h2 id="why-it-works"><a href="#why-it-works" class="headerlink" title="why it works:"></a>why it works:</h2><p>1) When the slow pointer enters the loop, the fast pointer is already inside the loop. Set the distance between the fast pointer and the slow pointer be K.<br>2) Now, if we consider the slow movement of the pointers, we can notice that the distance between them increases by one after each iteration. After an iteration (slow pointer = next node of slow pointer, fast pointer = next next node of fast pointer), the distance between fast pointer and slow pointer becomes K + 1, after two iterations, it is K + 2, and so on. When the distance becomes the length n of the ring, they will join because they move in a ring of length n.<br>For example, we can see in the following figure that the initial distance is 2. After one iteration, the distance becomes 3, and after two iterations, the distance becomes 4. After three iterations, it becomes 5. It is also  distance 0. They meet.</p>
<p><img src="/images/pasted-6.png" alt="upload successful"><br><img src="./img/cycle_det2.jpeg" alt=""></p>
<h2 id="complexity"><a href="#complexity" class="headerlink" title="complexity"></a>complexity</h2><ul>
<li>Time complexity: O(n).<br>Only one traversal of the loop is needed.</li>
<li>Auxiliary Space:O(1).<br>There is no space required.</li>
</ul>
<h2 id="implement-in-Python"><a href="#implement-in-Python" class="headerlink" title="implement in Python"></a>implement in Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Leercide 141. Linked List Cycle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        slow = head </span><br><span class="line">        fast = head  </span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next </span><br><span class="line">            fast = fast.next.next </span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="Extend-knowledge"><a href="#Extend-knowledge" class="headerlink" title="Extend knowledge"></a>Extend knowledge</h2><ul>
<li>question：<ul>
<li>How to  the length of the cycle?</li>
<li>How to find the first node in a cycle (i.e. linked list cycle II)?</li>
<li>How to change a linked list into a single linked list?</li>
<li>How to judge whether two single linked lists have intersection? How to find the first intersection node?</li>
</ul>
</li>
</ul>
<p><img src="/images/pasted-7.png" alt=""><br>The distance traveled by slow at the first encounter: <code>a+b</code>, the distance traveled by fast: <code>a+b+c+b</code>.Because the speed of fast is twice that of slow, the distance traveled by fast is twice that of slow. There are <code>2(a+b) = a+b+c+b</code>, and you can get <code>a=c</code> (this conclusion is very important!</p>
<p>We found that L=b+c=a+b, that is,</p>
<ol>
<li>From the beginning to the first encounter of the two points, the number of cycles is equal to the length of the ring.</li>
<li>We have already reached the conclusion a=c, then let the two pointers start from X and Z, one step at a time, then it will meet at Y!That is the first node of the ring.</li>
<li>At the end of the previous question, the link between the node before point Y in segment c and Y can be cut off.</li>
<li>How to judge whether two singly linked lists have intersection?First determine whether the two linked lists have cycles, if one has cycles and one has no cycles, it must not intersect; if both have no rings, determine whether the tails of the two lists are equal; if both have cycles, determine the Z on a linked list Whether the point is on another linked list.<br>Here is an example to return the node cycles begins(142. Linked List Cycle II)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next </span><br><span class="line">            fast = fast.next.next </span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                slow = head </span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">if</span> slow == fast:</span><br><span class="line">                        <span class="keyword">return</span> slow </span><br><span class="line">                    slow = slow.next</span><br><span class="line">                    fast = fast.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.csdn.net/ccmlove123/article/details/104052556">https://blog.csdn.net/ccmlove123/article/details/104052556</a><br><a href="https://blog.csdn.net/xy010902100449/article/details/48995255">https://blog.csdn.net/xy010902100449/article/details/48995255</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-01T17:48:00.000Z" title="2020-07-01T17:48:00.000Z">2020-07-01</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">3 minutes read (About 506 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/01/Topological-sorting/">Topological sorting</a></h1><div class="content"><h2 id="1-defintation"><a href="#1-defintation" class="headerlink" title="1. defintation:"></a>1. defintation:</h2><p>Topological sorting problem: given digraph G = (V, E) ,<br>find a linear ordering of vertices such that:<br>for all edges (v, w) in E, v precedes w in the ordering.</p>
<p><img src="/images/pasted-3.png" alt="upload successful"><br>Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.</p>
<h2 id="2-alogrithm"><a href="#2-alogrithm" class="headerlink" title="2.alogrithm"></a>2.alogrithm</h2><ul>
<li>Step 1: Identify vertices that have no incoming edge<br>• The <code>in-degree</code> of these vertices is zero<br>If no such edges, graph has cycles (cyclic graph)</li>
<li>Step 2: Delete this vertex of in-degree 0 and all its<br>outgoing edges from the graph. Place it in the output.</li>
<li>Step 3: Repeat Steps 1 and Step 2 until graph is empty</li>
</ul>
<h2 id="3-implemented-in-Python"><a href="#3-implemented-in-Python" class="headerlink" title="3. implemented in Python"></a>3. implemented in Python</h2><p><img src="/images/pasted-4.png" alt="upload successful"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python program to print topological sorting of a DAG</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="comment">#Class to represent a graph</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,vertices)</span>:</span></span><br><span class="line">        self.graph = defaultdict(list) <span class="comment">#dictionary containing adjacency List</span></span><br><span class="line">        self.V = vertices <span class="comment">#No. of vertices</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># function to add an edge to graph</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addEdge</span><span class="params">(self,u,v)</span>:</span></span><br><span class="line">        self.graph[u].append(v)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># A recursive function used by topologicalSort</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topologicalSortUtil</span><span class="params">(self,v,visited,stack)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Mark the current node as visited.</span></span><br><span class="line">        visited[v] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recur for all the vertices adjacent to this vertex</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.graph[v]:</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="literal">False</span>:</span><br><span class="line">                self.topologicalSortUtil(i,visited,stack)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Push current vertex to stack which stores result</span></span><br><span class="line">        stack.insert(<span class="number">0</span>,v)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The function to do Topological Sort. It uses recursive  </span></span><br><span class="line">    <span class="comment"># topologicalSortUtil()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topologicalSort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Mark all the vertices as not visited</span></span><br><span class="line">        visited = [<span class="literal">False</span>]*self.V</span><br><span class="line">        stack =[]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Call the recursive helper function to store Topological</span></span><br><span class="line">        <span class="comment"># Sort starting from all vertices one by one</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.V):</span><br><span class="line">            <span class="keyword">if</span> visited[i] == <span class="literal">False</span>:</span><br><span class="line">                self.topologicalSortUtil(i,visited,stack)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Print contents of the stack</span></span><br><span class="line">        print(stack)</span><br><span class="line"></span><br><span class="line">g= Graph(<span class="number">6</span>)</span><br><span class="line">g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">g.topologicalSort()</span><br><span class="line"><span class="comment">#This code is contributed by Neelam Yadav</span></span><br></pre></td></tr></table></figure></p>
<p>Another implementation can be seen:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def topoSort(graph):     </span><br><span class="line">    in_degrees &#x3D; dict((u,0) for u in graph)   #初始化所有顶点入度为0     </span><br><span class="line">    num &#x3D; len(in_degrees)     </span><br><span class="line">    for u in graph:         </span><br><span class="line">        for v in graph[u]:             </span><br><span class="line">            in_degrees[v] +&#x3D; 1    #计算每个顶点的入度     </span><br><span class="line">    Q &#x3D; [u for u in in_degrees if in_degrees[u] &#x3D;&#x3D; 0]   # 筛选入度为0的顶点     </span><br><span class="line">    Seq &#x3D; []     </span><br><span class="line">    while Q:         </span><br><span class="line">        u &#x3D; Q.pop()       #默认从最后一个删除         </span><br><span class="line">        Seq.append(u)         </span><br><span class="line">        for v in graph[u]:             </span><br><span class="line">            in_degrees[v] -&#x3D; 1    #移除其所有出边</span><br><span class="line">            if in_degrees[v] &#x3D;&#x3D; 0:        </span><br><span class="line">                Q.append(v)          #再次筛选入度为0的顶点</span><br><span class="line">    if len(Seq) &#x3D;&#x3D; num:       #输出的顶点数是否与图中的顶点数相等</span><br><span class="line">        return Seq     </span><br><span class="line">    else:         </span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">G &#x3D; &#123;</span><br><span class="line">    &#39;a&#39;:&#39;bf&#39;,</span><br><span class="line">    &#39;b&#39;:&#39;cdf&#39;,</span><br><span class="line">    &#39;c&#39;:&#39;d&#39;,</span><br><span class="line">    &#39;d&#39;:&#39;ef&#39;,</span><br><span class="line">    &#39;e&#39;:&#39;f&#39;,</span><br><span class="line">    &#39;f&#39;:&#39;&#39;</span><br><span class="line">&#125;</span><br><span class="line">print(topoSort(G))</span><br></pre></td></tr></table></figure></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>geeksforgeeks.org/topological-sorting/</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-28T17:03:00.000Z" title="2020-06-28T17:03:00.000Z">2020-06-28</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">18 minutes read (About 2642 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/28/tree-algorithm-in-Python/">tree algorithm in Python</a></h1><div class="content"><h2 id="Definition-what-is-tree"><a href="#Definition-what-is-tree" class="headerlink" title="Definition: what is tree?"></a>Definition: what is tree?</h2><p>two important features:</p>
<ul>
<li>connected</li>
<li>no cycles</li>
</ul>
<blockquote>
<p>a feature of tree: the number of edges is number of nodes - proof : remove the root node</p>
</blockquote>
<p>application: Graph Valid Tree<br>Check if a given graph is tree or not</p>
<ul>
<li><p>How to detect cycle in an undirected graph?<br>We can either use BFS or DFS. For every visited vertex <code>v</code>, if there is an adjacent <code>u</code> such that <code>u</code> is already visited and <code>u</code> is not parent of <code>v</code>, then there is a cycle in graph. If we don’t find such an adjacent for any vertex, we say that there is no cycle (See Detect cycle in an undirected graph for more details).</p>
</li>
<li><p>How to check for connectivity?<br>Since the graph is undirected, we can start BFS or DFS from any vertex and check if all vertices are reachable or not. If all vertices are reachable, then graph is connected, otherwise not.</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment"># BFS solution. Same complexity but faster version.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer&#125; n</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[][]&#125; edges</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span><span class="params">(self, n, edges)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(edges) != n - <span class="number">1</span>:  <span class="comment"># Check number of edges. - there is the Definition of the tree</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># init node's neighbors in dict</span></span><br><span class="line">        neighbors = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">            neighbors[u].append(v)</span><br><span class="line">            neighbors[v].append(u)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># BFS to check whether the graph is valid tree.</span></span><br><span class="line">        q = collections.deque([<span class="number">0</span>])</span><br><span class="line">        visited = set([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            curr = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> neighbors[curr]:</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(node)</span><br><span class="line">                    q.append(node)</span><br><span class="line">        <span class="keyword">return</span> len(visited) == n</span><br></pre></td></tr></table></figure>
<h3 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h3><ul>
<li><p>Node</p>
<p>  A node is a fundamental part of a tree. It can have a name, which we call the “key.” A node may also have additional information. We call this additional information the “payload.” While the payload information is not central to many tree algorithms, it is often critical in applications that make use of trees.</p>
</li>
<li><p>Edge</p>
<p>  An edge is another fundamental part of a tree. An edge connects two nodes to show that there is a relationship between them. Every node (except the root) is connected by exactly one incoming edge from another node. Each node may have several outgoing edges.</p>
</li>
<li><p>Root</p>
<p>  The root of the tree is the only node in the tree that has no incoming edges.</p>
</li>
<li><p>Path</p>
<p>  A path is an ordered list of nodes that are connected by edges. For example, Mammal → Carnivora → Felidae → Felis → Domestica is a path.</p>
</li>
<li><p>Children</p>
<p>  The set of nodes 𝑐 that have incoming edges from the same node to are said to be the children of that node.</p>
</li>
<li><p>Parent</p>
<p>  A node is the parent of all the nodes it connects to with outgoing edges.</p>
</li>
<li><p>Sibling</p>
<p>  Nodes in the tree that are children of the same parent are said to be siblings.</p>
</li>
<li><p>Subtree</p>
<p>  A subtree is a set of nodes and edges comprised of a parent and all the descendants of that parent.</p>
</li>
<li><p>Leaf Node</p>
<p>  A leaf node is a node that has no children.</p>
</li>
<li><p>Level</p>
<p>  The level of a node 𝑛 is the number of edges on the path from the root node to 𝑛.</p>
</li>
<li><p>Height</p>
<p>  The height of a tree is equal to the maximum level of any node in the tree.</p>
</li>
<li><p>degree</p>
<p>  The degree of a tree is the maximum degree of a node in the tree. For example:If the maximum degree of a node is 2, then it is a binary tree. Likewise, if the maximum degree of a node is 3, then it becomes a ternary tree.P.S: Degree of a node is the maximum number of child nodes it can have.</p>
</li>
</ul>
<h3 id="Binary-tree"><a href="#Binary-tree" class="headerlink" title="Binary tree"></a>Binary tree</h3><p>a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p>
<ul>
<li>how to implement it in Python<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left_child = <span class="literal">None</span></span><br><span class="line">        self.right_child = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_left</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.left_child == <span class="literal">None</span>:</span><br><span class="line">            self.left_child = BinaryTree(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node = BinaryTree(value)</span><br><span class="line">            new_node.left_child = self.left_child</span><br><span class="line">            self.left_child = new_node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_right</span><span class="params">(self, value)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> self.right_child == <span class="literal">None</span>:</span><br><span class="line">                self.right_child = BinaryTree(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_node = BinaryTree(value)</span><br><span class="line">                new_node.right_child = self.right_child</span><br><span class="line">                self.right_child = new_node</span><br></pre></td></tr></table></figure>
<h3 id="tree-traversal"><a href="#tree-traversal" class="headerlink" title="tree traversal"></a>tree traversal</h3>there are two options:<br>Depth-First Search (DFS) and Breadth-First Search (BFS).</li>
<li><p>DFS<br>Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures.. We can simply begin from a node, then traverse its adjacent (or children) without caring about cycles. And if we begin from a single node (root), and traverse this way, it is guaranteed that we traverse the whole tree as there is no dis-connectivity,<br>There are three ways in tree traversal:</p>
<ul>
<li><p>preorder</p>
<blockquote>
<p>Algorithm Preorder(tree)</p>
<ol>
<li>Visit the root.</li>
<li>Traverse the left subtree, i.e., call Preorder(left-subtree)</li>
<li>Traverse the right subtree, i.e., call Preorder(right-subtree)</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="comment"># recursive</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                ret.append(node.val)</span><br><span class="line">                fn(node.left)</span><br><span class="line">                fn(node.right)</span><br><span class="line">        fn(root)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment"># iterative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack):</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ret.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<ul>
<li>application:</li>
</ul>
<ol>
<li>Leetcode 1028. Recover a Tree From Preorder Traversal</li>
<li>Leetcode 144. Binary Tree Preorder Traversal</li>
<li>Leetcode 971. Flip Binary Tree To Match Preorder Traversal</li>
<li>Leetcode 589. N-ary Tree Preorder Traversal</li>
<li>Leetcode 331. Verify Preorder Serialization of a Binary Tree</li>
</ol>
</li>
<li><p>inorder</p>
<blockquote>
<p>Algorithm Inorder(tree)</p>
<ol>
<li>Traverse the left subtree, i.e., call Inorder(left-subtree)</li>
<li>Visit the root.</li>
<li>Traverse the right subtree, i.e., call Inorder(right-subtree)</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<pre><code>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key)</span>:</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.val = key</span><br><span class="line"></span><br><span class="line">ret = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inOrderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        inOrderTraversal(root.left)</span><br><span class="line">        ret.append(root.val)</span><br><span class="line">        inOrderTraversal(root.right)</span><br></pre></td></tr></table></figure>
- application:
1. Leetcode 94. Binary Tree Inorder Traversal
2. Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal
</code></pre><ul>
<li><p>postorder</p>
<blockquote>
<p>Algorithm Postorder(tree)</p>
<ol>
<li>Traverse the left subtree, i.e., call Postorder(left-subtree)</li>
<li>Traverse the right subtree, i.e., call Postorder(right-subtree)</li>
<li>Visit the root.</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="comment"># recursive</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                dfs(root.left)</span><br><span class="line">                dfs(root.right)</span><br><span class="line">                ret.append(root.val)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment">#iterative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            ret.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> ret[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>application:<ol>
<li>Leetcode 590. N-ary Tree Postorder Traversal</li>
<li>Leetcode 145. Binary Tree Postorder Traversal</li>
<li>Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal</li>
</ol>
<ul>
<li>BFS<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFStraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        stack = deque([root])</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            ret.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.appendleft(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.appendleft(cur.right)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="full-binary-tree-vs-complete-binary-tree"><a href="#full-binary-tree-vs-complete-binary-tree" class="headerlink" title="full binary tree vs complete binary tree"></a>full binary tree vs complete binary tree</h2></li>
<li>A <code>full binary tree</code> (sometimes proper binary tree or 2-tree) is a tree in which every node other than the leaves has two children.<br>some proporty of full binary tree:<br>1） The total number of nodes of full binary tree is at most  $2^i -1 $<br>2） And the number of non-leaf node is one less than the leaf node.</li>
<li>proof 1:<br>The number of nodes of each layer form a geometric sequence. Image we have a tree which has $i$ layers.<br>The number of nodes in the last layer is $2^{i-1}$<br>And to compute the total number of the tree, we could use the sum formula of geometric sequence: $\frac{a_1 - a_nq}{1-q}$.So the result will be $2^{i}-1$.</li>
<li>proof 2:<br>We set the set of nodes with two child nodes  is F and leaf node is L. For full tree, we only have these two kind of nodes.<br>only leaf node can generate child nodes, so the total number of nodes can be represent 1 + 2F (1 is the root node)<br>Also, the total number can be represented as F+L</li>
</ul>
</li>
</ul>
<p>1+2F = F+ L<br>so that L = 1+ F</p>
</li>
</ul>
<ul>
<li>A <code>complete binary tree</code>  is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible</li>
<li><code>AVL tree</code> is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes (for every node).</li>
</ul>
<h2 id="binary-search-tree-BST"><a href="#binary-search-tree-BST" class="headerlink" title="binary search tree (BST)"></a>binary search tree (BST)</h2><p>An important property of a Binary Search Tree is that the value of a Binary Search Tree nodeis larger than the value of the offspring of its left child, but smaller than the value of the offspring of its right child.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left_child = <span class="literal">None</span></span><br><span class="line">        self.right_child = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_node</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= self.value <span class="keyword">and</span> self.left_child:</span><br><span class="line">            self.left_child.insert_node(value)</span><br><span class="line">        <span class="keyword">elif</span> value &lt;= self.value:</span><br><span class="line">            self.left_child = BinarySearchTree(value)</span><br><span class="line">        <span class="keyword">elif</span> value &gt; self.value <span class="keyword">and</span> self.right_child:</span><br><span class="line">            self.right_child.insert_node(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.right_child = BinarySearchTree(value)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>application:<ol>
<li>Leetcode 109. Convert Sorted List to Binary Search Tree</li>
<li>Leetcode 96. Unique Binary Search Trees</li>
<li>Leetcode 95. Unique Binary Search Trees II</li>
<li>Leetcode 1008. Construct Binary Search Tree from Preorder Traversal</li>
<li>Leetcode 235. Lowest Common Ancestor of a Binary Search Tree</li>
<li>Leetcode 98. Validate Binary Search Tree</li>
<li>Leetcode 108. Convert Sorted Array to Binary Search Tree</li>
</ol>
</li>
</ul>
<h2 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h2><ul>
<li>defination :a trie, also called digital tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings.Here’s a trie that stores “David”, “Maria”, and “Mario”.</li>
</ul>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<ul>
<li>Strengths<ul>
<li>Sometimes Space-Efficient. If you’re storing lots of words that start with similar patterns, tries may reduce the overall storage cost by storing shared prefixes once.</li>
<li>Efficient Prefix Queries. Tries can quickly answer queries about words with shared prefixes, like:<ul>
<li>How many words start with “choco”?</li>
<li>What’s the most likely next letter in a word that starts with “strawber”?</li>
</ul>
</li>
</ul>
</li>
<li>Weaknesses<ul>
<li>Usually Space-Inefficient. Tries rarely save space when compared to storing strings in a set.</li>
<li>ASCII characters in a string are one byte each. Each link between trie nodes is a pointer to an address—eight bytes on a 64-bit system. So, the overhead of linking nodes together often outweighs the savings from storing fewer characters.</li>
<li>Not Standard. Most languages don’t come with a built-in trie implementation. You’ll need to implement one yourself.</li>
</ul>
</li>
</ul>
<p>What happens if we have two words and one is a prefix of the other?<br>we need to mark the word ending like using another node or True</p>
<p>Here is an example<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Leetcode 208:Implement Trie (Prefix Tree)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line">        self.endofWord = <span class="literal">False</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(word)</span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">not</span> <span class="keyword">in</span> start.children:</span><br><span class="line">                start.children[word[i]] = TrieNode()</span><br><span class="line">            start = start.children[word[i]]</span><br><span class="line">        start.endofWord = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(word)</span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">not</span> <span class="keyword">in</span> start.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            start = start.children[word[i]]</span><br><span class="line">        <span class="keyword">return</span> start.endofWord</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prefix)</span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> prefix[i] <span class="keyword">not</span> <span class="keyword">in</span> start.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            start = start.children[prefix[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Radix-tree"><a href="#Radix-tree" class="headerlink" title="Radix tree"></a>Radix tree</h2><p>a radix tree (also radix trie or compact prefix tree) is a data structure that represents a space-optimized trie (prefix tree) in which each node that is the only child is merged with its parent. The result is that the number of children of every internal node is at most the radix r of the radix tree, where r is a positive integer and a power x of 2.</p>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<h2 id="segment-tree"><a href="#segment-tree" class="headerlink" title="segment tree"></a>segment tree</h2><ul>
<li><p>defination:<br>Segment Tree is a basically a binary tree used for storing the intervals or segments. Each node in the Segment Tree represents an interval. Consider an array  of size  N and a corresponding Segment Tree T.(It is AVL)</p>
<ol>
<li>The root of T will represent the whole array A[:N] .</li>
<li>Each leaf in the Segment Tree T  will represent a single element A[i]  such that 0 &lt;= i &lt; N.</li>
<li>The internal nodes in the Segment Tree  represents the union of elementary intervals A[i:j]  where  0&lt;= i&lt;j&lt; N.</li>
</ol>
</li>
<li>application:<br>Sum of given range</li>
<li>image:</li>
</ul>
<p><img src="/images/pasted-12.png" alt="segement tree"></p>
<h2 id="Binary-Indexed-Tree"><a href="#Binary-Indexed-Tree" class="headerlink" title="Binary Indexed Tree"></a>Binary Indexed Tree</h2><ul>
<li>what is binary indexed tree<br>As the name suggests, it is to use arrays to simulate tree structures. Then a question arises, why not build trees directly? The answer is  there is no need to build trees for problems that arrays can handle. It is similar to the structure of trie tree.</li>
<li>For what<br>update and sum for a interval</li>
<li>binary indexed tree vs segement tree<br>The problems that a binary indexed tree can solve can be solved with a line segment tree. What is the difference between the two?The coefficient of the tree array is much less.</li>
<li>advantages vs disadvantages<br>The complexity of modification and query is O(logN), and the coefficient is much less than that of the line segment tree, faster than the traditional array, and easy to write.The disadvantage is that it still cannot be solved when encountering complex interval problems, and the function is still limited.</li>
<li>understand the binary indexed</li>
</ul>
<p><img src="/images/pasted-13.png" alt="binary_indexed_tree.png"><br>The black array represents the original array (replaced with A[i] below), and the red structure represents our tree-like array (replaced with C[i] below).<br>The rules can be seen as follows</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C[1] &#x3D; A[1];</span><br><span class="line">C[2] &#x3D; A[1] + A[2];</span><br><span class="line">C[3] &#x3D; A[3];</span><br><span class="line">C[4] &#x3D; A[1] + A[2] + A[3] + A[4];</span><br><span class="line">C[5] &#x3D; A[5];</span><br><span class="line">C[6] &#x3D; A[5] + A[6];</span><br><span class="line">C[7] &#x3D; A[7];</span><br><span class="line">C[8] &#x3D; A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];</span><br><span class="line">C[i] &#x3D; A[i - 2k+1] + A[i - 2k+2] + ... + A[i];&#x2F;&#x2F;k is the length of consecutive zeros from the lowest bit to the highest bit in the binary of i</span><br></pre></td></tr></table></figure>
<p>More detail :<br><a href="https://www.youtube.com/watch?v=CWDQJGaN1gY">https://www.youtube.com/watch?v=CWDQJGaN1gY</a></p>
<ul>
<li><p>operation</p>
<ul>
<li><p>sum</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> getSum(x): Returns the sum of the sub-array arr[0,...,x]</span><br><span class="line">&#x2F;&#x2F; Returns the sum of the sub-array arr[0,...,x] using BITree[0..n], which is constructed from arr[0..n-1]</span><br><span class="line">1) Initialize the output sum as 0, the current index as x+1.</span><br><span class="line">2) Do following while the current index is greater than 0.</span><br><span class="line">...a) Add BITree[index] to sum</span><br><span class="line">...b) Go to the parent of BITree[index].  The parent can be obtained by removing</span><br><span class="line">     the last set bit from the current index, i.e., index &#x3D; index - (index &amp; (-index))</span><br><span class="line">3) Return sum.</span><br></pre></td></tr></table></figure>
<p>get_sum_tree.png<br><img src="/images/pasted-14.png" alt="get_sum_tree.png"></p>
<ul>
<li><p>update</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    update(x, val): Updates the Binary Indexed Tree (BIT) by performing arr[index] +&#x3D; val</span><br><span class="line">&#x2F;&#x2F; Note that the update(x, val) operation will not change arr[].  It only makes changes to BITree[]</span><br><span class="line">1) Initialize the current index as x+1.</span><br><span class="line">2) Do the following while the current index is smaller than or equal to n.</span><br><span class="line">...a) Add the val to BITree[index]</span><br><span class="line">...b) Go to parent of BITree[index].  The parent can be obtained by incrementing</span><br><span class="line">     the last set bit of the current index, i.e., index &#x3D; index + (index &amp; (-index))</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-15.png" alt="update_tree.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>implementation</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python implementation of Binary Indexed Tree</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns sum of arr[0..index]. This function assumes</span></span><br><span class="line"><span class="comment"># that the array is preprocessed and partial sums of</span></span><br><span class="line"><span class="comment"># array elements are stored in BITree[].</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getsum</span><span class="params">(BITTree,i)</span>:</span></span><br><span class="line">	s = <span class="number">0</span> <span class="comment">#initialize result</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># index in BITree[] is 1 more than the index in arr[]</span></span><br><span class="line">	i = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Traverse ancestors of BITree[index]</span></span><br><span class="line">	<span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">		<span class="comment"># Add current element of BITree to sum</span></span><br><span class="line">		s += BITTree[i]</span><br><span class="line"></span><br><span class="line">		<span class="comment"># Move index to parent node in getSum View</span></span><br><span class="line">		i -= i &amp; (-i)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># Updates a node in Binary Index Tree (BITree) at given index</span></span><br><span class="line"><span class="comment"># in BITree. The given value 'val' is added to BITree[i] and</span></span><br><span class="line"><span class="comment"># all of its ancestors in tree.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatebit</span><span class="params">(BITTree , n , i ,v)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># index in BITree[] is 1 more than the index in arr[]</span></span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Traverse all ancestors and add 'val'</span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= n:</span><br><span class="line"></span><br><span class="line">		<span class="comment"># Add 'val' to current node of BI Tree</span></span><br><span class="line">		BITTree[i] = v</span><br><span class="line"></span><br><span class="line">		<span class="comment"># Update index to that of parent in update View</span></span><br><span class="line">		i += i &amp; (-i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Constructs and returns a Binary Indexed Tree for given</span></span><br><span class="line"><span class="comment"># array of size n.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct</span><span class="params">(arr, n)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Create and initialize BITree[] as 0</span></span><br><span class="line">	BITTree = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Store the actual values in BITree[] using update()</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		updatebit(BITTree, n, i, arr[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Uncomment below lines to see contents of BITree[]</span></span><br><span class="line">	<span class="comment">#for i in range(1,n+1):</span></span><br><span class="line">	<span class="comment">#	 print BITTree[i],</span></span><br><span class="line">	<span class="keyword">return</span> BITTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code to test above methods</span></span><br><span class="line">freq = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">BITTree = construct(freq,len(freq))</span><br><span class="line">print(<span class="string">"Sum of elements in arr[0..5] is "</span> + str(getsum(BITTree,<span class="number">5</span>)))</span><br><span class="line">freq[<span class="number">3</span>] += <span class="number">6</span></span><br><span class="line">updatebit(BITTree, len(freq), <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">print(<span class="string">"Sum of elements in arr[0..5]"</span>+</span><br><span class="line">					<span class="string">" after update is "</span> + str(getsum(BITTree,<span class="number">5</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This code is contributed by Raju Varshney</span></span><br></pre></td></tr></table></figure>
<ul>
<li>example:<br>Leetcode 307 Range Sum Query - Mutable<br>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.<br>The update(i, val) function modifies nums by updating the element at index i to val.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">      self.nums = nums</span><br><span class="line">      self.N = len(self.nums)</span><br><span class="line">      self.tree = [<span class="number">0</span>] * (self.N + <span class="number">1</span>)</span><br><span class="line">      <span class="comment">## optimize initiate BIT in O(n)</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, self.N+<span class="number">1</span>):</span><br><span class="line">          self.tree[j] += self.nums[j<span class="number">-1</span>]</span><br><span class="line">          <span class="keyword">if</span> (j + (j &amp; (-j))) &lt;= self.N:</span><br><span class="line">              self.tree[j + (j &amp; (-j))] += self.tree[j]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, i, val)</span>:</span></span><br><span class="line">      diff = val - self.nums[i]</span><br><span class="line">      self.nums[i] = val</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> i &lt;= self.N:</span><br><span class="line">          self.tree[i] += diff</span><br><span class="line">          i += (i &amp; (-i))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> self.getSum(j) - self.getSum(i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, i)</span>:</span></span><br><span class="line">      sm = <span class="number">0</span></span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">          sm += self.tree[i]</span><br><span class="line">          i -= (i &amp; (-i))</span><br><span class="line">      <span class="keyword">return</span> sm</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Notice-distinguish-the-leaf-node-and-the-end-of-path"><a href="#Notice-distinguish-the-leaf-node-and-the-end-of-path" class="headerlink" title="Notice: distinguish the leaf node and the end of path"></a>Notice: distinguish the leaf node and the end of path</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>For example, Node 1 is the end of path but it is not the leaf node.<br>Leetcode 112. Path Sum</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/">https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/</a><br><a href="https://runestone.academy/runestone/books/published/pythonds/Trees/toctree.html">https://runestone.academy/runestone/books/published/pythonds/Trees/toctree.html</a><br><a href="https://www.cnblogs.com/xenny/p/9739600.html">https://www.cnblogs.com/xenny/p/9739600.html</a><br><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/">https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-16T22:12:00.000Z" title="2020-06-16T22:12:00.000Z">2020-06-16</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">6 minutes read (About 831 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/16/Dijkstra-s-algorithm/">Dijkstra&#039;s algorithm </a></h1><div class="content"><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>Dijkstra’s algorithm (or Dijkstra’s Shortest Path First algorithm, SPF algorithm) is an algorithm for finding the shortest paths between nodes in a graph.(Dijkstra algorithm is mainly used to find the minimum path from any point in a digraph whose weight is not negative to any other node (when two points are connected with each other).</p>
<h2 id="Dijkstra’s-algorithm-vs-BFS"><a href="#Dijkstra’s-algorithm-vs-BFS" class="headerlink" title="Dijkstra’s algorithm  vs BFS"></a>Dijkstra’s algorithm  vs BFS</h2><p>Breadth first search is suitable for unweighted graph to find  the shortest path of two points. Dijkstras algorithm, which is suitable for weighted graph to find the path with the least total weight.</p>
<h2 id="steps-of-algorithms"><a href="#steps-of-algorithms" class="headerlink" title="steps of algorithms"></a>steps of algorithms</h2><ol>
<li>A node <code>s</code> in the graph is given as the starting point.</li>
<li>Given an array <code>dist []</code> to store the distance from all nodes in the graph to <code>s</code>. Initialize <code>dist [s]</code> to 0. For other nodes <code>v</code> in the graph, the initial <code>dist [v]</code> is infinite. The significance of initializing to infinity is that we assume that all other nodes are not connected with s in the current situation. With the implementation of the algorithm, <code>dist [v]</code> will save the shortest path distance from <code>s</code> to <code>v</code> in the graph.</li>
<li>Given a minimum heap, record it as <code>Q</code>. The top of the stack  is the nearest node to s and the corresponding distance. Put <code>(s, 0)</code> in the heap.</li>
<li>Given a set, record it as <code>S</code>, and save all the visited nodes. Set it is initially empty. Based on the properties of Dijkstra algorithm, we always traverse every node with the shortest path, so for any node, once we have visited it, it means that we have got the shortest path from <code>s</code> to this node.</li>
<li>When <code>Q</code> is not empty, take out the element <code>(v, dist [v])</code> at the top of the heap, that is, the node v closest to <code>s</code> and its distance <code>dist [v]</code>.If <code>v</code> is in <code>S</code>, it represents the shortest path that we have visited <code>v</code>. Then skip the current v and repeat step 1.Otherwise, put <code>v</code> in <code>S</code>.</li>
<li>For each node t adjacent to v:<br>If <code>dist [v] + weight (v, t) &lt; dist [t]</code>, update <code>dist [t] = dist [v] + weight (v, t)</code>. At the same time, put <code>(t, dist [t])</code> into <code>Q</code>.<br>Otherwise, do nothing.</li>
<li>When the algorithm is finished, the weight value (or length) of the shortest path from each node except s in the graph to <code>s</code> is saved in <code>dist []</code>. If there is no connection path from <code>s</code> to <code>v</code>, <code>dist [v] = ∞</code>.</li>
</ol>
<h2 id="the-correctness-of-the-algorithm"><a href="#the-correctness-of-the-algorithm" class="headerlink" title="the correctness of the algorithm"></a>the correctness of the algorithm</h2><p>Suppose that <code>dist [v]</code> stores the shortest path from the starting point <code>s</code> to <code>v</code> for each node <code>v</code> that has been visited.<br>When the algorithm is initialized, only <code>dist [s] = 0</code> is included in<code>dist []</code>, and its correctness is obvious.</p>
<p>For the rest <code>n-1</code> nodes, if <code>u</code> has been accessed and <code>v</code> has not been accessed, and there is an edge <code>u - &gt; v</code> between <code>u</code> and <code>v</code>, whose weight is weight <code>(u, v)</code>, then there must be <code>dist [v] = dist [u] + weight (u, v)</code>. Otherwise, if there is another shorter path <code>dist [t]</code> satisfying <code>dist [t] + weight (t, v)</code>, then according to the above algorithm, t must be accessed before u, which conflicts with our current assumption. The conclusion is valid for all the remaining nodes.<br>Therefore, Dijkstra algorithm must be able to give the shortest path from the starting point to all other nodes .</p>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples:"></a>examples:</h2><p>a video from Youtube<br><a href="https://www.youtube.com/watch?v=pVfj6mxhdMw"><img src="https://i.ytimg.com/an_webp/pVfj6mxhdMw/mqdefault_6s.webp?du=3000&amp;sqp=CMj_n_cF&amp;rs=AOn4CLChjFa5pKK4y1TQtg-4m9feSO4prQ" alt="IMAGE ALT TEXT HERE"></a></p>
<h2 id="implement-in-Python"><a href="#implement-in-Python" class="headerlink" title="implement in Python"></a>implement in Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_distances</span><span class="params">(graph, starting_vertex)</span>:</span></span><br><span class="line">    distances = &#123;vertex: float(<span class="string">'infinity'</span>) <span class="keyword">for</span> vertex <span class="keyword">in</span> graph&#125;</span><br><span class="line">    distances[starting_vertex] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    pq = [(<span class="number">0</span>, starting_vertex)]</span><br><span class="line">    <span class="keyword">while</span> len(pq) &gt; <span class="number">0</span>:</span><br><span class="line">        current_distance, current_vertex = heapq.heappop(pq)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Nodes can get added to the priority queue multiple times. We only</span></span><br><span class="line">        <span class="comment"># process a vertex the first time we remove it from the priority queue.</span></span><br><span class="line">        <span class="keyword">if</span> current_distance &gt; distances[current_vertex]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph[current_vertex].items():</span><br><span class="line">            distance = current_distance + weight</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Only consider this new path if it's better than any path we've</span></span><br><span class="line">            <span class="comment"># already found.</span></span><br><span class="line">            <span class="keyword">if</span> distance &lt; distances[neighbor]:</span><br><span class="line">                distances[neighbor] = distance</span><br><span class="line">                heapq.heappush(pq, (distance, neighbor))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distances</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">example_graph = &#123;</span><br><span class="line">    <span class="string">'U'</span>: &#123;<span class="string">'V'</span>: <span class="number">2</span>, <span class="string">'W'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">'V'</span>: &#123;<span class="string">'U'</span>: <span class="number">2</span>, <span class="string">'X'</span>: <span class="number">2</span>, <span class="string">'W'</span>: <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="string">'W'</span>: &#123;<span class="string">'V'</span>: <span class="number">3</span>, <span class="string">'U'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">3</span>, <span class="string">'Y'</span>: <span class="number">1</span>, <span class="string">'Z'</span>: <span class="number">5</span>&#125;,</span><br><span class="line">    <span class="string">'X'</span>: &#123;<span class="string">'U'</span>: <span class="number">1</span>, <span class="string">'V'</span>: <span class="number">2</span>, <span class="string">'W'</span>: <span class="number">3</span>, <span class="string">'Y'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">'Y'</span>: &#123;<span class="string">'X'</span>: <span class="number">1</span>, <span class="string">'W'</span>: <span class="number">1</span>, <span class="string">'Z'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    <span class="string">'Z'</span>: &#123;<span class="string">'W'</span>: <span class="number">5</span>, <span class="string">'Y'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">print(calculate_distances(example_graph, <span class="string">'X'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="complexity"><a href="#complexity" class="headerlink" title="complexity"></a>complexity</h2><p>Suppose there are <code>E</code> edges and <code>N</code> nodes in the graph.<br>Time complexity: <code>O (ElogE)</code>. Because the minimum heap used is up to the <code>O (logE)</code> size,and we extract each element from it once.<br>Spatial complexity: <code>O (N + E)</code>. Where o (N) is the space used to store dist. <code>O (E)</code> is the space used to store the adjacency list and the minimum heap of a graph.</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.jianshu.com/p/cd97f8197f18">https://www.jianshu.com/p/cd97f8197f18</a></p>
<p><a href="https://bradfieldcs.com/algos/graphs/dijkstras-algorithm/">https://bradfieldcs.com/algos/graphs/dijkstras-algorithm/</a></p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/algorithm/page/0/">Previous</a></div><div class="pagination-next"><a href="/tags/algorithm/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/algorithm/">1</a></li><li><a class="pagination-link" href="/tags/algorithm/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.jpeg" alt="koko"></figure><p class="title is-size-4 is-block line-height-inherit">koko</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Troy, NY</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lawiet019" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lawiet019"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/math/"><span class="level-start"><span class="level-item">math</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/technology/"><span class="level-start"><span class="level-item">technology</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/technology/math/"><span class="level-start"><span class="level-item">math</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2021-09-02T01:11:00.000Z">2021-09-01</time></p><p class="title is-6"><a class="link-muted" href="/2021/09/01/notes-of-nginx-learning-3/">notes of nginx learning (3)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-08-24T16:30:00.000Z">2021-08-24</time></p><p class="title is-6"><a class="link-muted" href="/2021/08/24/notes-of-nginx-learning-2/">notes of nginx learning (2)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-08-23T17:42:00.000Z">2021-08-23</time></p><p class="title is-6"><a class="link-muted" href="/2021/08/23/notes-of-nginx-learning-1/">notes of  nginx learning (1)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2021-05-09T04:52:00.000Z">2021-05-09</time></p><p class="title is-6"><a class="link-muted" href="/2021/05/09/debugging-in-python/">debugging in python</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-12-29T15:37:00.000Z">2020-12-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/12/29/shortest-path-algorithm/">shortest path algorithm</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/09/"><span class="level-start"><span class="level-item">September 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/05/"><span class="level-start"><span class="level-item">May 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">December 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/11/"><span class="level-start"><span class="level-item">November 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Graph/"><span class="tag">Graph</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/binary-search/"><span class="tag">binary search</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bit-manipulation/"><span class="tag">bit manipulation</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/collections/"><span class="tag">collections</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/computing/"><span class="tag">computing</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debug/"><span class="tag">debug</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dynamic-programming/"><span class="tag">dynamic programming</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/graph/"><span class="tag">graph</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/learning-note/"><span class="tag">learning note</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linked-list/"><span class="tag">linked list</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/multiprocess/"><span class="tag">multiprocess</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/multithread/"><span class="tag">multithread</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag is-grey-lightest">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/regular-expression/"><span class="tag">regular expression</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sort/"><span class="tag">sort</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sorting/"><span class="tag">sorting</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tool/"><span class="tag">tool</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tree/"><span class="tag">tree</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.png" alt="lawilet&#039;s website" height="28"></a><p class="size-small"><span>&copy; 2021 lawiet019</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://law-liet.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>