<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>tree algorithm in Python - lawilet&#039;s website</title><meta description="Definition: what is tree?two important features:  connected no cycles   a feature of tree: the number of edges is number of nodes - proof : remove the root node  application: Graph Valid TreeCheck if"><meta property="og:type" content="blog"><meta property="og:title" content="tree algorithm in Python"><meta property="og:url" content="http://law-liet.com/2020/06/28/tree-algorithm-in-Python/"><meta property="og:site_name" content="lawilet&#039;s website"><meta property="og:description" content="Definition: what is tree?two important features:  connected no cycles   a feature of tree: the number of edges is number of nodes - proof : remove the root node  application: Graph Valid TreeCheck if"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://law-liet.com/images/pasted-10.png"><meta property="og:image" content="http://law-liet.com/images/pasted-11.png"><meta property="og:image" content="http://law-liet.com/images/pasted-12.png"><meta property="og:image" content="http://law-liet.com/images/pasted-13.png"><meta property="og:image" content="http://law-liet.com/images/pasted-14.png"><meta property="og:image" content="http://law-liet.com/images/pasted-15.png"><meta property="article:published_time" content="2020-06-28T17:03:00.000Z"><meta property="article:modified_time" content="2020-07-23T02:18:12.369Z"><meta property="article:author" content="lawiet019"><meta property="article:tag" content="python"><meta property="article:tag" content="algorithm"><meta property="article:tag" content="tree"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/pasted-10.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://law-liet.com/2020/06/28/tree-algorithm-in-Python/"},"headline":"lawilet's website","image":["http://law-liet.com/images/pasted-10.png","http://law-liet.com/images/pasted-11.png","http://law-liet.com/images/pasted-12.png","http://law-liet.com/images/pasted-13.png","http://law-liet.com/images/pasted-14.png","http://law-liet.com/images/pasted-15.png"],"datePublished":"2020-06-28T17:03:00.000Z","dateModified":"2020-07-23T02:18:12.369Z","author":{"@type":"Person","name":"lawiet019"},"description":"Definition: what is tree?two important features:  connected no cycles   a feature of tree: the number of edges is number of nodes - proof : remove the root node  application: Graph Valid TreeCheck if"}</script><link rel="canonical" href="http://law-liet.com/2020/06/28/tree-algorithm-in-Python/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.png" alt="lawilet&#039;s website" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/lawiet019"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-28T17:03:00.000Z" title="2020-06-28T17:03:00.000Z">2020-06-28</time><span class="level-item"> lawiet019 </span><span class="level-item"><a class="link-muted" href="/categories/technology/">technology</a></span><span class="level-item">16 minutes read (About 2444 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">tree algorithm in Python</h1><div class="content"><h2 id="Definition-what-is-tree"><a href="#Definition-what-is-tree" class="headerlink" title="Definition: what is tree?"></a>Definition: what is tree?</h2><p>two important features:</p>
<ul>
<li>connected</li>
<li>no cycles</li>
</ul>
<blockquote>
<p>a feature of tree: the number of edges is number of nodes - proof : remove the root node</p>
</blockquote>
<p>application: Graph Valid Tree<br>Check if a given graph is tree or not</p>
<ul>
<li><p>How to detect cycle in an undirected graph?<br>We can either use BFS or DFS. For every visited vertex <code>v</code>, if there is an adjacent <code>u</code> such that <code>u</code> is already visited and <code>u</code> is not parent of <code>v</code>, then there is a cycle in graph. If we don‚Äôt find such an adjacent for any vertex, we say that there is no cycle (See Detect cycle in an undirected graph for more details).</p>
</li>
<li><p>How to check for connectivity?<br>Since the graph is undirected, we can start BFS or DFS from any vertex and check if all vertices are reachable or not. If all vertices are reachable, then graph is connected, otherwise not.</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="comment"># BFS solution. Same complexity but faster version.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer&#125; n</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[][]&#125; edges</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span><span class="params">(self, n, edges)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(edges) != n - <span class="number">1</span>:  <span class="comment"># Check number of edges. - there is the Definition of the tree</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># init node's neighbors in dict</span></span><br><span class="line">        neighbors = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">            neighbors[u].append(v)</span><br><span class="line">            neighbors[v].append(u)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># BFS to check whether the graph is valid tree.</span></span><br><span class="line">        q = collections.deque([<span class="number">0</span>])</span><br><span class="line">        visited = set([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            curr = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> neighbors[curr]:</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(node)</span><br><span class="line">                    q.append(node)</span><br><span class="line">        <span class="keyword">return</span> len(visited) == n</span><br></pre></td></tr></table></figure>
<h3 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h3><ul>
<li><p>Node</p>
<p>  A node is a fundamental part of a tree. It can have a name, which we call the ‚Äúkey.‚Äù A node may also have additional information. We call this additional information the ‚Äúpayload.‚Äù While the payload information is not central to many tree algorithms, it is often critical in applications that make use of trees.</p>
</li>
<li><p>Edge</p>
<p>  An edge is another fundamental part of a tree. An edge connects two nodes to show that there is a relationship between them. Every node (except the root) is connected by exactly one incoming edge from another node. Each node may have several outgoing edges.</p>
</li>
<li><p>Root</p>
<p>  The root of the tree is the only node in the tree that has no incoming edges.</p>
</li>
<li><p>Path</p>
<p>  A path is an ordered list of nodes that are connected by edges. For example, Mammal ‚Üí Carnivora ‚Üí Felidae ‚Üí Felis ‚Üí Domestica is a path.</p>
</li>
<li><p>Children</p>
<p>  The set of nodes ùëê that have incoming edges from the same node to are said to be the children of that node.</p>
</li>
<li><p>Parent</p>
<p>  A node is the parent of all the nodes it connects to with outgoing edges.</p>
</li>
<li><p>Sibling</p>
<p>  Nodes in the tree that are children of the same parent are said to be siblings.</p>
</li>
<li><p>Subtree</p>
<p>  A subtree is a set of nodes and edges comprised of a parent and all the descendants of that parent.</p>
</li>
<li><p>Leaf Node</p>
<p>  A leaf node is a node that has no children.</p>
</li>
<li><p>Level</p>
<p>  The level of a node ùëõ is the number of edges on the path from the root node to ùëõ.</p>
</li>
<li><p>Height</p>
<p>  The height of a tree is equal to the maximum level of any node in the tree.</p>
</li>
<li><p>degree </p>
<p>  The degree of a tree is the maximum degree of a node in the tree. For example:If the maximum degree of a node is 2, then it is a binary tree. Likewise, if the maximum degree of a node is 3, then it becomes a ternary tree.P.S: Degree of a node is the maximum number of child nodes it can have.</p>
</li>
</ul>
<h3 id="Binary-tree"><a href="#Binary-tree" class="headerlink" title="Binary tree"></a>Binary tree</h3><p>a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p>
<ul>
<li>how to implement it in Python<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left_child = <span class="literal">None</span></span><br><span class="line">        self.right_child = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_left</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.left_child == <span class="literal">None</span>:</span><br><span class="line">            self.left_child = BinaryTree(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_node = BinaryTree(value)</span><br><span class="line">            new_node.left_child = self.left_child</span><br><span class="line">            self.left_child = new_node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_right</span><span class="params">(self, value)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> self.right_child == <span class="literal">None</span>:</span><br><span class="line">                self.right_child = BinaryTree(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_node = BinaryTree(value)</span><br><span class="line">                new_node.right_child = self.right_child</span><br><span class="line">                self.right_child = new_node</span><br></pre></td></tr></table></figure>
<h3 id="tree-traversal"><a href="#tree-traversal" class="headerlink" title="tree traversal"></a>tree traversal</h3>there are two options:<br>Depth-First Search (DFS) and Breadth-First Search (BFS).</li>
<li>DFS<br>Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures.. We can simply begin from a node, then traverse its adjacent (or children) without caring about cycles. And if we begin from a single node (root), and traverse this way, it is guaranteed that we traverse the whole tree as there is no dis-connectivity,<br>There are three ways in tree traversal:<ul>
<li>preorder<blockquote>
<p>Algorithm Preorder(tree)</p>
<ol>
<li>Visit the root.</li>
<li>Traverse the left subtree, i.e., call Preorder(left-subtree)</li>
<li>Traverse the right subtree, i.e., call Preorder(right-subtree)</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="comment"># recursive</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                ret.append(node.val)</span><br><span class="line">                fn(node.left)</span><br><span class="line">                fn(node.right)</span><br><span class="line">        fn(root)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment"># iterative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack):</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ret.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
- application:
  1. Leetcode 1028. Recover a Tree From Preorder Traversal
  2. Leetcode 144. Binary Tree Preorder Traversal
  3. Leetcode 971. Flip Binary Tree To Match Preorder Traversal
  4. Leetcode 589. N-ary Tree Preorder Traversal
  5. Leetcode 331. Verify Preorder Serialization of a Binary Tree
</code></pre><ul>
<li>inorder<blockquote>
<p>Algorithm Inorder(tree)</p>
<ol>
<li>Traverse the left subtree, i.e., call Inorder(left-subtree)</li>
<li>Visit the root.</li>
<li>Traverse the right subtree, i.e., call Inorder(right-subtree)</li>
</ol>
</blockquote>
</li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key)</span>:</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.val = key</span><br><span class="line"></span><br><span class="line">ret = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inOrderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        inOrderTraversal(root.left)</span><br><span class="line">        ret.append(root.val)</span><br><span class="line">        inOrderTraversal(root.right)</span><br></pre></td></tr></table></figure>
- application:
1. Leetcode 94. Binary Tree Inorder Traversal
2. Leetcode 105. Construct Binary Tree from Preorder and Inorder Traversal
</code></pre><ul>
<li><p>postorder</p>
<blockquote>
<p>Algorithm Postorder(tree)</p>
<ol>
<li>Traverse the left subtree, i.e., call Postorder(left-subtree)</li>
<li>Traverse the right subtree, i.e., call Postorder(right-subtree)</li>
<li>Visit the root.</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="comment"># recursive</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                dfs(root.left)</span><br><span class="line">                dfs(root.right)</span><br><span class="line">                ret.append(root.val)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment">#iterative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            ret.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> ret[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>application:<ol>
<li>Leetcode 590. N-ary Tree Postorder Traversal</li>
<li>Leetcode 145. Binary Tree Postorder Traversal</li>
<li>Leetcode 106. Construct Binary Tree from Inorder and Postorder Traversal</li>
</ol>
<ul>
<li>BFS<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">BFStraversal</span><span class="params">(self,root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        stack = deque([root])</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            ret.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.appendleft(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.appendleft(cur.right)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="full-binary-tree-vs-complete-binary-tree"><a href="#full-binary-tree-vs-complete-binary-tree" class="headerlink" title="full binary tree vs complete binary tree"></a>full binary tree vs complete binary tree</h2></li>
<li>A <code>full binary tree</code> (sometimes proper binary tree or 2-tree) is a tree in which every node other than the leaves has two children. </li>
<li>A <code>complete binary tree</code>  is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible</li>
<li><code>AVL tree</code> is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes (for every node).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="binary-search-tree-BST"><a href="#binary-search-tree-BST" class="headerlink" title="binary search tree (BST)"></a>binary search tree (BST)</h2><p>An important property of a Binary Search Tree is that the value of a Binary Search Tree nodeis larger than the value of the offspring of its left child, but smaller than the value of the offspring of its right child.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left_child = <span class="literal">None</span></span><br><span class="line">        self.right_child = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_node</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= self.value <span class="keyword">and</span> self.left_child:</span><br><span class="line">            self.left_child.insert_node(value)</span><br><span class="line">        <span class="keyword">elif</span> value &lt;= self.value:</span><br><span class="line">            self.left_child = BinarySearchTree(value)</span><br><span class="line">        <span class="keyword">elif</span> value &gt; self.value <span class="keyword">and</span> self.right_child:</span><br><span class="line">            self.right_child.insert_node(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.right_child = BinarySearchTree(value)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>application:<ol>
<li>Leetcode 109. Convert Sorted List to Binary Search Tree</li>
<li>Leetcode 96. Unique Binary Search Trees</li>
<li>Leetcode 95. Unique Binary Search Trees II</li>
<li>Leetcode 1008. Construct Binary Search Tree from Preorder Traversal</li>
<li>Leetcode 235. Lowest Common Ancestor of a Binary Search Tree</li>
<li>Leetcode 98. Validate Binary Search Tree</li>
</ol>
</li>
</ul>
<h2 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h2><ul>
<li>defination :a trie, also called digital tree or prefix tree, is a kind of search tree‚Äîan ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings.Here‚Äôs a trie that stores ‚ÄúDavid‚Äù, ‚ÄúMaria‚Äù, and ‚ÄúMario‚Äù.</li>
</ul>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<ul>
<li>Strengths<ul>
<li>Sometimes Space-Efficient. If you‚Äôre storing lots of words that start with similar patterns, tries may reduce the overall storage cost by storing shared prefixes once.</li>
<li>Efficient Prefix Queries. Tries can quickly answer queries about words with shared prefixes, like:<ul>
<li>How many words start with ‚Äúchoco‚Äù?</li>
<li>What‚Äôs the most likely next letter in a word that starts with ‚Äústrawber‚Äù?</li>
</ul>
</li>
</ul>
</li>
<li>Weaknesses<ul>
<li>Usually Space-Inefficient. Tries rarely save space when compared to storing strings in a set.</li>
<li>ASCII characters in a string are one byte each. Each link between trie nodes is a pointer to an address‚Äîeight bytes on a 64-bit system. So, the overhead of linking nodes together often outweighs the savings from storing fewer characters.</li>
<li>Not Standard. Most languages don‚Äôt come with a built-in trie implementation. You‚Äôll need to implement one yourself.</li>
</ul>
</li>
</ul>
<p>What happens if we have two words and one is a prefix of the other?<br>we need to mark the word ending like using another node or True</p>
<p>Here is an example<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Leetcode 208:Implement Trie (Prefix Tree)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line">        self.endofWord = <span class="literal">False</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(word)</span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">not</span> <span class="keyword">in</span> start.children:</span><br><span class="line">                start.children[word[i]] = TrieNode()</span><br><span class="line">            start = start.children[word[i]]</span><br><span class="line">        start.endofWord = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(word)</span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">not</span> <span class="keyword">in</span> start.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            start = start.children[word[i]]</span><br><span class="line">        <span class="keyword">return</span> start.endofWord</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prefix)</span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> prefix[i] <span class="keyword">not</span> <span class="keyword">in</span> start.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            start = start.children[prefix[i]]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Radix-tree"><a href="#Radix-tree" class="headerlink" title="Radix tree"></a>Radix tree</h2><p>a radix tree (also radix trie or compact prefix tree) is a data structure that represents a space-optimized trie (prefix tree) in which each node that is the only child is merged with its parent. The result is that the number of children of every internal node is at most the radix r of the radix tree, where r is a positive integer and a power x of 2.</p>
<p><img src="/images/pasted-11.png" alt="upload successful"></p>
<h2 id="segment-tree"><a href="#segment-tree" class="headerlink" title="segment tree"></a>segment tree</h2><ul>
<li><p>defination:<br>Segment Tree is a basically a binary tree used for storing the intervals or segments. Each node in the Segment Tree represents an interval. Consider an array  of size  N and a corresponding Segment Tree T.(It is AVL)</p>
<ol>
<li>The root of T will represent the whole array A[:N] . </li>
<li>Each leaf in the Segment Tree T  will represent a single element A[i]  such that 0 &lt;= i &lt; N.</li>
<li>The internal nodes in the Segment Tree  represents the union of elementary intervals A[i:j]  where  0&lt;= i&lt;j&lt; N.</li>
</ol>
</li>
<li>application:<br>Sum of given range</li>
<li>image:</li>
</ul>
<p><img src="/images/pasted-12.png" alt="segement tree"></p>
<h2 id="Binary-Indexed-Tree"><a href="#Binary-Indexed-Tree" class="headerlink" title="Binary Indexed Tree"></a>Binary Indexed Tree</h2><ul>
<li>what is binary indexed tree<br>As the name suggests, it is to use arrays to simulate tree structures. Then a question arises, why not build trees directly? The answer is  there is no need to build trees for problems that arrays can handle. It is similar to the structure of trie tree.</li>
<li>For what<br>update and sum for a interval</li>
<li>binary indexed tree vs segement tree<br>The problems that a binary indexed tree can solve can be solved with a line segment tree. What is the difference between the two?The coefficient of the tree array is much less.</li>
<li>advantages vs disadvantages<br>The complexity of modification and query is O(logN), and the coefficient is much less than that of the line segment tree, faster than the traditional array, and easy to write.The disadvantage is that it still cannot be solved when encountering complex interval problems, and the function is still limited.</li>
<li>understand the binary indexed </li>
</ul>
<p><img src="/images/pasted-13.png" alt="binary_indexed_tree.png"><br>The black array represents the original array (replaced with A[i] below), and the red structure represents our tree-like array (replaced with C[i] below).<br>The rules can be seen as follows</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C[1] &#x3D; A[1];</span><br><span class="line">C[2] &#x3D; A[1] + A[2];</span><br><span class="line">C[3] &#x3D; A[3];</span><br><span class="line">C[4] &#x3D; A[1] + A[2] + A[3] + A[4];</span><br><span class="line">C[5] &#x3D; A[5];</span><br><span class="line">C[6] &#x3D; A[5] + A[6];</span><br><span class="line">C[7] &#x3D; A[7];</span><br><span class="line">C[8] &#x3D; A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];</span><br><span class="line">C[i] &#x3D; A[i - 2k+1] + A[i - 2k+2] + ... + A[i];&#x2F;&#x2F;k is the length of consecutive zeros from the lowest bit to the highest bit in the binary of i</span><br></pre></td></tr></table></figure>
<p>More detail :<br><a href="https://www.youtube.com/watch?v=CWDQJGaN1gY">https://www.youtube.com/watch?v=CWDQJGaN1gY</a></p>
<ul>
<li><p>operation</p>
<ul>
<li><p>sum </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> getSum(x): Returns the sum of the sub-array arr[0,...,x]</span><br><span class="line">&#x2F;&#x2F; Returns the sum of the sub-array arr[0,...,x] using BITree[0..n], which is constructed from arr[0..n-1]</span><br><span class="line">1) Initialize the output sum as 0, the current index as x+1.</span><br><span class="line">2) Do following while the current index is greater than 0.</span><br><span class="line">...a) Add BITree[index] to sum</span><br><span class="line">...b) Go to the parent of BITree[index].  The parent can be obtained by removing</span><br><span class="line">     the last set bit from the current index, i.e., index &#x3D; index - (index &amp; (-index))</span><br><span class="line">3) Return sum.</span><br></pre></td></tr></table></figure>
<p>get_sum_tree.png<br><img src="/images/pasted-14.png" alt="get_sum_tree.png"></p>
<ul>
<li><p>update</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    update(x, val): Updates the Binary Indexed Tree (BIT) by performing arr[index] +&#x3D; val</span><br><span class="line">&#x2F;&#x2F; Note that the update(x, val) operation will not change arr[].  It only makes changes to BITree[]</span><br><span class="line">1) Initialize the current index as x+1.</span><br><span class="line">2) Do the following while the current index is smaller than or equal to n.</span><br><span class="line">...a) Add the val to BITree[index]</span><br><span class="line">...b) Go to parent of BITree[index].  The parent can be obtained by incrementing</span><br><span class="line">     the last set bit of the current index, i.e., index &#x3D; index + (index &amp; (-index))</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-15.png" alt="update_tree.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>implementation</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python implementation of Binary Indexed Tree </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns sum of arr[0..index]. This function assumes </span></span><br><span class="line"><span class="comment"># that the array is preprocessed and partial sums of </span></span><br><span class="line"><span class="comment"># array elements are stored in BITree[]. </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getsum</span><span class="params">(BITTree,i)</span>:</span> </span><br><span class="line">	s = <span class="number">0</span> <span class="comment">#initialize result </span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># index in BITree[] is 1 more than the index in arr[] </span></span><br><span class="line">	i = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Traverse ancestors of BITree[index] </span></span><br><span class="line">	<span class="keyword">while</span> i &gt; <span class="number">0</span>: </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Add current element of BITree to sum </span></span><br><span class="line">		s += BITTree[i] </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Move index to parent node in getSum View </span></span><br><span class="line">		i -= i &amp; (-i) </span><br><span class="line">	<span class="keyword">return</span> s </span><br><span class="line"></span><br><span class="line"><span class="comment"># Updates a node in Binary Index Tree (BITree) at given index </span></span><br><span class="line"><span class="comment"># in BITree. The given value 'val' is added to BITree[i] and </span></span><br><span class="line"><span class="comment"># all of its ancestors in tree. </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatebit</span><span class="params">(BITTree , n , i ,v)</span>:</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment"># index in BITree[] is 1 more than the index in arr[] </span></span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Traverse all ancestors and add 'val' </span></span><br><span class="line">	<span class="keyword">while</span> i &lt;= n: </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Add 'val' to current node of BI Tree </span></span><br><span class="line">		BITTree[i] = v </span><br><span class="line"></span><br><span class="line">		<span class="comment"># Update index to that of parent in update View </span></span><br><span class="line">		i += i &amp; (-i) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Constructs and returns a Binary Indexed Tree for given </span></span><br><span class="line"><span class="comment"># array of size n. </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">construct</span><span class="params">(arr, n)</span>:</span> </span><br><span class="line"></span><br><span class="line">	<span class="comment"># Create and initialize BITree[] as 0 </span></span><br><span class="line">	BITTree = [<span class="number">0</span>]*(n+<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">	<span class="comment"># Store the actual values in BITree[] using update() </span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n): </span><br><span class="line">		updatebit(BITTree, n, i, arr[i]) </span><br><span class="line"></span><br><span class="line">	<span class="comment"># Uncomment below lines to see contents of BITree[] </span></span><br><span class="line">	<span class="comment">#for i in range(1,n+1): </span></span><br><span class="line">	<span class="comment">#	 print BITTree[i], </span></span><br><span class="line">	<span class="keyword">return</span> BITTree </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code to test above methods </span></span><br><span class="line">freq = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] </span><br><span class="line">BITTree = construct(freq,len(freq)) </span><br><span class="line">print(<span class="string">"Sum of elements in arr[0..5] is "</span> + str(getsum(BITTree,<span class="number">5</span>))) </span><br><span class="line">freq[<span class="number">3</span>] += <span class="number">6</span></span><br><span class="line">updatebit(BITTree, len(freq), <span class="number">3</span>, <span class="number">6</span>) </span><br><span class="line">print(<span class="string">"Sum of elements in arr[0..5]"</span>+</span><br><span class="line">					<span class="string">" after update is "</span> + str(getsum(BITTree,<span class="number">5</span>))) </span><br><span class="line"></span><br><span class="line"><span class="comment"># This code is contributed by Raju Varshney</span></span><br></pre></td></tr></table></figure>
<ul>
<li>example:<br>Leetcode 307 Range Sum Query - Mutable<br>Given an integer array nums, find the sum of the elements between indices i and j (i ‚â§ j), inclusive.<br>The update(i, val) function modifies nums by updating the element at index i to val.<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">      self.nums = nums</span><br><span class="line">      self.N = len(self.nums)</span><br><span class="line">      self.tree = [<span class="number">0</span>] * (self.N + <span class="number">1</span>)</span><br><span class="line">      <span class="comment">## optimize initiate BIT in O(n)</span></span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, self.N+<span class="number">1</span>):</span><br><span class="line">          self.tree[j] += self.nums[j<span class="number">-1</span>]</span><br><span class="line">          <span class="keyword">if</span> (j + (j &amp; (-j))) &lt;= self.N:</span><br><span class="line">              self.tree[j + (j &amp; (-j))] += self.tree[j]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, i, val)</span>:</span></span><br><span class="line">      diff = val - self.nums[i]</span><br><span class="line">      self.nums[i] = val</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> i &lt;= self.N:</span><br><span class="line">          self.tree[i] += diff</span><br><span class="line">          i += (i &amp; (-i))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> self.getSum(j) - self.getSum(i - <span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, i)</span>:</span></span><br><span class="line">      sm = <span class="number">0</span></span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">          sm += self.tree[i]</span><br><span class="line">          i -= (i &amp; (-i))</span><br><span class="line">      <span class="keyword">return</span> sm</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/">https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/</a><br><a href="https://runestone.academy/runestone/books/published/pythonds/Trees/toctree.html">https://runestone.academy/runestone/books/published/pythonds/Trees/toctree.html</a><br><a href="https://www.cnblogs.com/xenny/p/9739600.html">https://www.cnblogs.com/xenny/p/9739600.html</a><br><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/">https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/</a></p>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/python/">python</a><a class="link-muted mr-2" rel="tag" href="/tags/algorithm/">algorithm</a><a class="link-muted mr-2" rel="tag" href="/tags/tree/">tree</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/07/01/Topological-sorting/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Topological sorting</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/26/common-modules-in-Python-1-collections/"><span class="level-item">common modules in Python(1) :collections</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="/img/avatar.jpeg" alt="koko"></figure><p class="title is-size-4 is-block line-height-inherit">koko</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Troy, NY</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Category</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/lawiet019" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/lawiet019"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/technology/"><span class="level-start"><span class="level-item">technology</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-27T19:21:00.000Z">2020-07-27</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/27/Untitled/">Untitled</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-22T17:48:00.000Z">2020-07-22</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/22/Learning-of-wireshark/">Learning of wireshark</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-12T16:18:00.000Z">2020-07-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/12/common-modules-in-python-6-bisect/">common_modules_in_python(6):bisect</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-12T16:05:00.000Z">2020-07-12</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/12/common-modules-in-python-5-math/">common_modules_in_python(5):math</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-06T17:52:00.000Z">2020-07-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/06/common-modules-in-python-4/">common_modules_in_python(4):itertools</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/technology/">technology</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Graph/"><span class="tag">Graph</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bit-manipulation/"><span class="tag">bit manipulation</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/collections/"><span class="tag">collections</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dynamic-programming/"><span class="tag">dynamic programming</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linked-list/"><span class="tag">linked list</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag is-grey-lightest">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/regular-expression/"><span class="tag">regular expression</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sort/"><span class="tag">sort</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sorting/"><span class="tag">sorting</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tree/"><span class="tag">tree</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.png" alt="lawilet&#039;s website" height="28"></a><p class="size-small"><span>&copy; 2020 lawiet019</span>¬†¬†Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>¬†&amp;¬†<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://law-liet.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">√ó</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>