{"pages":[{"title":"about","text":"this is just a demo of about","link":"/about/index.html"},{"title":"Build the blog with hexo","text":"My work mainly follows the instruction on https://www.simon96.online/2018/10/12/hexo-tutorial/ 1. prepared workinstall nodejs/ git 2. install hexo command line1$ npm install -g hexo-cli 3. init the folder for hexo123$ hexo init &lt;folder&gt; # generate the hexo folder$ cd &lt;folder&gt;$ npm install # npm will download and install according to the dependency configuration in the package.json configuration file 4. start the server1$ hexo s Then open the link http://localhost:4000/ to check whether the blog can run in localhost 5.publish my blog on a remote addresschoose github pages and purchased domain new a repososity name &lt;githubname&gt;.github.io also set the original hexo folder as &lt;githubname&gt;.github.io install hexo-deployer-git plugin modifiy the configuration file named _config.yml1234deploy: type: git repo: git@github.com:&lt;Github account name&gt;/&lt;the repososity we created before&gt; branch: master generate new pages and push them to remote12$ hexo g$ hexo d now we can visit our blog on https://.github.io buy a domain on Godaddy set the DNS as follows create a file named CNAME under source folderand inside the file, write my domain and use command to push the modified to github files wait some miniutes then I could visit my website on my domain 6.change the theme of hexochoose the theme named icarus and its github link ishttps://github.com/ppoffice/hexo-theme-icarus.Put the downloaded folder under the themes folder. And change the setting of the whole hexo project in _config.yml and change the setting of the theme in the themes/hexo-theme-icarus/_config.yml.The main changes In the _config.yml set title, author and time zone 1234567title: lawilet's websitesubtitle: ''description: ''keywords:author: lawiet019language: entimezone: 'America/New_York' set the theme 1theme: hexo-theme-icarus In the themes/hexo-theme-icarus/_config.yml change the logo and favicon 12345logo: /img/favicon.png# Page metadata configurationshead: # URL or path to the website's icon favicon: /img/favicon.png Also change the settings in the widgets labels like the link to github. block the comments,payment and so on. And remember to generate and deploy again. 7. add about page install the hexo-admin1npm install --save hexo-admin enter the admin address like localhost:4000/admin create a new page named about remaining problems: comments plugin: I tried the gitalk. But sincemy domain didnot support https so it doesnot work.","link":"/Build-the-blog-with-hexo/index.html"},{"title":"bit manipulation in python","text":"","link":"/bit-manipulation-in-python/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/09/hello-world/"},{"title":"Build the blog with hexo","text":"My work mainly follows the instruction on https://www.simon96.online/2018/10/12/hexo-tutorial/ 1. prepared workinstall nodejs/ git 2. install hexo command line1$ npm install -g hexo-cli 3. init the folder for hexo123$ hexo init &lt;folder&gt; # generate the hexo folder$ cd &lt;folder&gt;$ npm install # npm will download and install according to the dependency configuration in the package.json configuration file 4. start the server1$ hexo s Then open the link http://localhost:4000/ to check whether the blog can run in localhost 5.publish my blog on a remote addresschoose github pages and purchased domain new a repososity name &lt;githubname&gt;.github.io also set the original hexo folder as &lt;githubname&gt;.github.io install hexo-deployer-git plugin modifiy the configuration file named _config.yml1234deploy: type: git repo: git@github.com:&lt;Github account name&gt;/&lt;the repososity we created before&gt; branch: master generate new pages and push them to remote12$ hexo g$ hexo d now we can visit our blog on https://.github.io buy a domain on Godaddy set the DNS as follows create a file named CNAME under source folderand inside the file, write my domain and use command to push the modified to github files wait some miniutes then I could visit my website on my domain 6.change the theme of hexochoose the theme named icarus and its github link ishttps://github.com/ppoffice/hexo-theme-icarus.Put the downloaded folder under the themes folder. And change the setting of the whole hexo project in _config.yml and change the setting of the theme in the themes/hexo-theme-icarus/_config.yml.The main changes In the _config.yml set title, author and time zone 1234567title: lawilet's websitesubtitle: ''description: ''keywords:author: lawiet019language: entimezone: 'America/New_York' set the theme 1theme: hexo-theme-icarus In the themes/hexo-theme-icarus/_config.yml change the logo and favicon 12345logo: /img/favicon.png# Page metadata configurationshead: # URL or path to the website's icon favicon: /img/favicon.png Also change the settings in the widgets labels like the link to github. block the comments,payment and so on. And remember to generate and deploy again. 7. add about page install the hexo-admin1npm install --save hexo-admin enter the admin address like localhost:4000/admin create a new page named about remaining problems: comments plugin: I tried the gitalk. But sincemy domain didnot support https so it doesnot work.","link":"/2020/05/12/Build-the-blog-with-hexo/"},{"title":"sorting alogrithms in python","text":"The materials are based on geekforgeek and https://www.cnblogs.com/onepixel/articles/7674659.html bubble sortBubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.If we rank n elements, we need n-1 comparisons, so K comparisons need n-k comparisons.The comparison times are: (n-1) + (n-2) +… + 1 = n * (n-1) / 2, so the time complexity of bubble sorting is O (n ^ 2).The worse case and average are both O (n ^ 2)best case is O(n) (if we use flag)Space complexity: 1 Algorithm Introduction: Compare adjacent elements, the former is larger than the latter (or the former is smaller than the latter) and change positions Repeat the work for each pair of adjacent elements from the beginning to the end. After this step is completed, the end is the largest or smallest number Repeat the above steps for the last element. Repeat steps 1-3 until sorting is completed to implement it in Python 12345678910111213141516171819# increasing orderdef bubbleSort(aList): n = len(aList) for i in range(n-1): # the index of loop for j in range(1,n-i): # the index of element if aList[j]&lt; aList[j-1]: aList[j],aList[j-1] = aList[j-1],aList[j] return aListdef bubbleSortWithFlag(aList): n = len(aList) for i in range(n-1): # the index of loop flag = False for j in range(1,n-i): # the index of element if aList[j]&lt; aList[j-1]: flag = True aList[j],aList[j-1] = aList[j-1],aList[j] if not flag: return aList selection sortThe selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array. 1) The subarray which is already sorted.2) Remaining subarray which is unsorted. In every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray. Algorithm Introduction: the smallest (large) element is found in the unsorted sequence and stored at the beginning of the sorted sequence ( we can still use the original array as the sorted sequence by swapping). continue to find the smallest (largest) element from the remaining unsorted elements, and put it at the end of the sorted sequence.Repeat the second step until all elements are sorted. Worst complexity: O(n^2)Average complexity:O(n^2)Best complexity: O(n^2)Space complexity: O(1) 12345678910111213def selectionSort(aList): n = len(aList) for i in range(n-1): for j in range(i,n): if j ==i: small_value = aList[j] small_index = j else: if aList[j] &lt; small_value: small_value = aList[j] small_index = j aList[i],aList[small_index] = aList[small_index],aList[i] return aList Insertion SortThe idea of insertion sorting is to maintain an ordered area and insert data one by one into the proper position of the ordered area until the whole array is ordered.Generally speaking, insertion sorting is implemented on array by in place. The specific algorithm is described as follows: Algorithm Introduction: Starting from the first element, the element can be considered to have been sorted; Take out the next element and scan from the back to the front in the sorted element sequence; If the element (sorted) is larger than the new element, move the element to the next location; Repeat step 3 until the ordered element is less than or equal to the position of the new element; After inserting the new element into the location;Repeat steps 2-5. Worst complexity: n^2Average complexity: n^2Best complexity: nSpace complexity: 1 123456789101112def insertionSort(aList): n = len(aList) for i in range(1,n): # save the index and value of i temp = aList[i] j =i # find the location to put i while j&gt;0 and aList[j-1]&gt; temp: aList[j] = aList[j-1] j -=1 aList[j] = temp return aList shell sortshell sort is also called reduced incremental sort. Its essence is insertion sort. It just divides the sequence to be sorted into several subsequences according to some rules, and directly inserts and sorts these subsequences respectively. The embodiment of this rule is the selection of increment. If the selected increment is 1, then it is insertion sort. And each sorting of shell sort will make the whole sequence orderly. When the whole sequence is orderly, then insert sort with increment of 1 will improve the sorting efficiency.The commonly used increment is 2-span increment, so every time you sort, the increment is half of the last one, which is what we often call shell increment. Algorithm Introduction: Select an incremental sequence t1, t2 , tk, where ti &gt; tj, tk = 1; By the number k of incremental sequence, the sequence is sorted by k times; According to the corresponding increment ti, the sequence to be sorted is divided into several subsequences with length of m, and each subsequence is inserted and sorted directly. Only when the increment factor is 1, the whole sequence is treated as a table, and the table length is the length of the whole sequence. time complexity:O(nlogn)～O(n^2)space complexity: O(1) 12345678910111213141516def shellSort(aList): n = len(aList) # init gap gap = n//2 while gap &gt;=1: print(gap) # do the insertion sort based on different gaps for i in range(gap,n): temp = aList[i] j =i while j&gt;= gap and aList[j-gap]&gt;temp: aList[j] = aList[j-gap] j = j-gap aList[j] = temp gap = gap //2 return aList merge sortMerge sort is a divide and conquer algorithm. First divide the list into the smallest unit (1 element), then compare each element with the adjacent list to sort and merge the two adjacent lists. Finally all the elements are sorted. Algorithm Introduction: The input sequence of length n is divided into two subsequences of length n / 2; The two subsequences are sorted by merging; Merge two sorted subsequences into a final sorting sequence. Worst complexity: nlog(n)Average complexity: nlog(n)Best complexity: n*log(n)Space complexity: n 123456789101112131415161718192021222324252627282930313233def merge(a,b): ret_list = [] a_i = 0 b_i =0 len_a = len(a) len_b = len(b) while a_i&lt;= len_a -1 and b_i&lt;= len_b -1: if a[a_i]&lt;= b[b_i]: ret_list.append(a[a_i]) a_i = a_i+1 else: ret_list.append(b[b_i]) b_i = b_i+1 while a_i &lt;=len_a -1: ret_list.append(a[a_i]) a_i = a_i+1 while b_i &lt;=len_b -1: ret_list.append(b[b_i]) b_i = b_i+1 return ret_listdef mergeSort(aList): n = len(aList) # divide n into two parts if n &gt;=2: mid = n//2 left = mergeSort(aList[:mid]) right =mergeSort(aList[mid:]) # merge it finally return merge(left,right) else: return aList quick sortQuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways. Always pick first element as pivot. Always pick last element as pivot (implemented below) Pick a random element as pivot. Pick median as pivot. The key process in quickSort is partition(). Target of partitions is, given an array and an element x of array as pivot, put x at its correct position in sorted array and put all smaller elements (smaller than x) before x, and put all greater elements (greater than x) after x. All this should be done in linear time. Worst complexity: n^2Average complexity: nlog(n)Best complexity: nlog(n) 1234567891011121314151617def quickSort(aList): # choose the first element as pivot if len(aList)&lt;=1: return aList pivot = aList[0] left = [] right = [] for i in range(1,len(aList)): if aList[i]&lt;pivot: left.append(aList[i]) else: right.append(aList[i]) left = quickSort(left) right = quickSort(right) left.append(pivot) left.extend(right) return left heap sortHeap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element. What is Binary Heap?Let us first define a Complete Binary Tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible (Source Wikipedia) A Binary Heap is a Complete Binary Tree where items are stored in a special order such that value in a parent node is greater(or smaller) than the values in its two children nodes. The former is called as max heap and the latter is called min heap. The heap can be represented by binary tree or array. Why array based representation for Binary Heap?Since a Binary Heap is a Complete Binary Tree, it can be easily represented as array and array based representation is space efficient. If the parent node is stored at index I, the left child can be calculated by 2 * I + 1 and right child by 2 * I + 2 (assuming the indexing starts at 0). Heap Sort Algorithm for sorting in increasing order: Build a max heap from the input data. At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree. Repeat above steps while size of heap is greater than 1. How to build the heap?Heapify procedure can be applied to a node only if its children nodes are heapified. So the heapification must be performed in the bottom up order. Lets understand with the help of an example: 12345678910111213141516171819202122232425Input data: 4, 10, 3, 5, 1 4(0) / \\ 10(1) 3(2) / \\ 5(3) 1(4)The numbers in bracket represent the indices in the arrayrepresentation of data.Applying heapify procedure to index 1: 4(0) / \\ 10(1) 3(2) / \\5(3) 1(4)Applying heapify procedure to index 0: 10(0) / \\ 5(1) 3(2) / \\ 4(3) 1(4)The heapify procedure calls itself recursively to build heap in top down manner. Worst complexity: nlog(n)Average complexity: nlog(n)Best complexity: n*log(n)Space complexity: 1 we will start our heapify on the the last non-leaf node. To get it, we know that the index value of the last leaf node is n-1, and its parent node index value is [(n-1) - 1] / 2 = n / 2 - 1. And after we build a max heap, More detail Explanation on heap sort is https://www.cnblogs.com/chengxiao/p/6129630.html 12345678910111213141516171819202122def heapify(aList,n,i): left = 2*i + 1 right = 2*i +2 largest = i if left&lt;n and aList[left]&gt;aList[largest]: largest = left if right&lt;n and aList[right]&gt;aList[largest]: largest = right if largest != i: aList[largest],aList[i] = aList[i],aList[largest] heapify(aList,n,largest)def heapSort(aList): n = len(aList) #build the max heap for i in range(n//2 -1,-1,-1): heapify(aList,n,i) # get the element based on the order (from the root) for i in range(n-1,0,-1): aList[0],aList[i] = aList[i],aList[0] heapify(aList,i,0) return aList counting sortIt is applicable to a certain range of integer sorting. When the value range is not very large, its performance is even faster than those o (nlogn) sorting in some cases, such as fast sorting and merging sorting.Let us understand it with the help of an example 12345678910111213141516171819For simplicity, consider the data in the range 0 to 9.Input data: 1, 4, 1, 2, 7, 5, 2 1) Take a count array to store the count of each unique object. Index: 0 1 2 3 4 5 6 7 8 9 Count: 0 2 2 0 1 1 0 1 0 0 2) Modify the count array such that each element at each index stores the sum of previous counts. Index: 0 1 2 3 4 5 6 7 8 9 Count: 0 2 4 4 5 6 6 7 7 7The modified count array indicates the position of each object inthe output sequence. 3) Output each object from the input sequence followed by decreasing its count by 1. Process the input data: 1, 4, 1, 2, 7, 5, 2. Position of 1 is 2. Put data 1 at index 2 in output. Decrease count by 1 to place next data 1 at an index 1 smaller than this index. 12345678910111213141516def countingSort(aList): min_v = min(aList) max_v = max(aList) rag = max_v - min_v +1 n = len(aList) num_counter = {} for i in range(rag): num_counter[min_v+i] = 0 for i in range(n): num_counter[aList[i]] +=1 ret_list = [] for i in range(rag): ret_list.extend([min_v+i]*num_counter[min_v+ i]) return ret_list bucket sortBucket Sort is a sorting technique that sorts the elements by first dividing the elements into several groups called buckets. The elements inside each bucket are sorted using any of the suitable sorting algorithms or recursively calling the same algorithm.bucketSort(arr[], n) 1) Create n empty buckets (Or lists).2) Do following for every array element arr[i].…….a) Insert arr[i] into bucket[n*array[i]]3) Sort individual buckets using insertion sort.4) Concatenate all sorted buckets. If we assume that insertion in a bucket takes O(1) time then steps 1 and 2 of the above algorithm clearly take O(n) time. The O(1) is easily possible if we use a linked list to represent a bucket (In the following code, C++ vector is used for simplicity). Step 4 also takes O(n) time as there will be n items in all buckets. 123456789101112131415161718192021222324252627282930313233def insertionSort(b): for i in range(1, len(b)): up = b[i] j = i - 1 while j &gt;=0 and b[j] &gt; up: b[j + 1] = b[j] j -= 1 b[j + 1] = up return b def bucketSort(x): arr = [] slot_num = 10 # 10 means 10 slots, each # slot's size is 0.1 for i in range(slot_num): arr.append([]) # Put array elements in different buckets for j in x: index_b = int(slot_num * j) arr[index_b].append(j) # Sort individual buckets for i in range(slot_num): arr[i] = insertionSort(arr[i]) # concatenate the result k = 0 for i in range(slot_num): for j in range(len(arr[i])): x[k] = arr[i][j] k += 1 return x Radix SortRadix sort is an extension of bucket sort. Its basic idea is to cut integers into different numbers according to the number of digits, and then compare them according to each digit.The specific method is: unify all the values to be compared into the same digit length, and fill zero in front of the shorter digit. Then, start from the lowest order and sort one by one. In this way, from the lowest ranking to the completion of the highest ranking, the sequence becomes an ordered sequence. Algorithm Introduction: Gets the maximum number in the array and the number of digits of the maximun number ; if arr is the original array, and each bit is taken from the lowest bit to form a radix array; To count and sort the radix (use counting sort); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def countingSort(arr, exp1): n = len(arr) # The output array elements that will have sorted arr output = [0] * (n) # initialize count array as 0 count = [0] * (10) # Store count of occurrences in count[] for i in range(0, n): index = (arr[i]/exp1) count[ (index)%10 ] += 1 # Change count[i] so that count[i] now contains actual # position of this digit in output array for i in range(1,10): count[i] += count[i-1] # Build the output array i = n-1 while i&gt;=0: index = (arr[i]/exp1) output[ count[ (index)%10 ] - 1] = arr[i] count[ (index)%10 ] -= 1 i -= 1 # Copying the output array to arr[], # so that arr now contains sorted numbers i = 0 for i in range(0,len(arr)): arr[i] = output[i]# Method to do Radix Sortdef radixSort(arr): # Find the maximum number to know number of digits max1 = max(arr) # Do counting sort for every digit. Note that instead # of passing digit number, exp is passed. exp is 10^i # where i is current digit number exp = 1 while max1/exp &gt; 0: countingSort(arr,exp) exp *= 10 TimsortThe alogrithm python used for sort and sorted is Timsort. the difference between sort and sorted, is that sorted will generate and return a new array Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort.We divide the Array into blocks known as Run. We sort those runs using insertion sort one by one and then merge those runs using combine function used in merge sort. If the size of Array is less than run, then Array get sorted just by using Insertion Sort. The size of run may vary from 32 to 64 depending upon the size of the array. Note that merge function performs well when sizes subarrays are powers of 2. The idea is based on the fact that insertion sort performs well for small arrays.Details of below implementation : We consider size of run as 32.We one by one sort pieces of size equal to runAfter sorting individual pieces, we merge them one by one. We double the size of merged subarrays after every iteration. Another version of timsort：https://segmentfault.com/a/1190000020280815 attribute value time complexity(best) O(n) time complexity(average) O(nlogn ) time complexity(worse) O(nlogn ) space complexity O(n) stable yes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# Python3 program to perform TimSort. RUN = 32 # This function sorts array from left index to # to right index which is of size atmost RUN def insertionSort(arr, left, right): for i in range(left + 1, right+1): temp = arr[i] j = i - 1 while j &gt;= left and arr[j] &gt; temp : arr[j+1] = arr[j] j -= 1 arr[j+1] = temp # merge function merges the sorted runs def merge(arr, l, m, r): # original array is broken in two parts # left and right array len1, len2 = m - l + 1, r - m left, right = [], [] for i in range(0, len1): left.append(arr[l + i]) for i in range(0, len2): right.append(arr[m + 1 + i]) i, j, k = 0, 0, l # after comparing, we merge those two array # in larger sub array while i &lt; len1 and j &lt; len2: if left[i] &lt;= right[j]: arr[k] = left[i] i += 1 else: arr[k] = right[j] j += 1 k += 1 # copy remaining elements of left, if any while i &lt; len1: arr[k] = left[i] k += 1 i += 1 # copy remaining element of right, if any while j &lt; len2: arr[k] = right[j] k += 1 j += 1 # iterative Timsort function to sort the # array[0...n-1] (similar to merge sort) def timSort(arr, n): # Sort individual subarrays of size RUN for i in range(0, n, RUN): insertionSort(arr, i, min((i+31), (n-1))) # start merging from size RUN (or 32). It will merge # to form size 64, then 128, 256 and so on .... size = RUN while size &lt; n: # pick starting point of left sub array. We # are going to merge arr[left..left+size-1] # and arr[left+size, left+2*size-1] # After every merge, we increase left by 2*size for left in range(0, n, 2*size): # find ending point of left sub array # mid+1 is starting point of right sub array mid = left + size - 1 right = min((left + 2*size - 1), (n-1)) # merge sub array arr[left.....mid] &amp; # arr[mid+1....right] merge(arr, left, mid, right) size = 2*size The analysis of sorting algorithmshttps://www.geeksforgeeks.org/analysis-of-different-sorting-techniques/","link":"/2020/05/23/sorting-alogrithms-in-python/"},{"title":"bit manipulation in python","text":"these materials are based on https://www.zhihu.com/question/38206659 Basic of bitwise Operations not (~)If the number of not is an unsigned integer (it cannot represent a negative number), the result is the difference between it and the upper bound of the type 12~1 -&gt; 0~0 -&gt; 1 and （&amp;）The and operation is usually used for get a certain bit. For example, the result of x &amp; 1 is to get the last bit of x. This can be used to judge the parity of an integer. The last bit of a binary is 0, which means the number is even, and the last bit is 1, which means the number is odd 1231 &amp; 1 -&gt; 10 &amp; 0 -&gt; 00 &amp; 1 -&gt; 0 or (|)Or operation is usually used for assignment on binary special bit. For example, the result of x |1 is to make the last bit of x to 1. If you need to change the last bit of binary number to 0, you can use x &amp; 1 -1. Its practical meaning is to force the number to the nearest even number 1231 | 1 -&gt; 10 | 0 -&gt; 01 | 0 -&gt; 1 xor (^)if we xor the same number twice,we will get the number itself 1231 ^ 1 -&gt; 00 ^ 0 -&gt; 01 ^ 0 -&gt; 1 right shift(&gt;&gt;):Right shift is equivalent to dividing the bit pattern with 2k ( if we are shifting k bits ).the least-significant bit is lost, and a 0 bit is inserted on the other end(if the number has no sign bit) 12a = 8: 0000 0000 0000 0000 0000 0000 0000 1000a &gt;&gt; 3: 0000 0000 0000 0000 0000 0000 0000 0001 left shift(&lt;&lt;): Right shift is equivalent to multipling the bit pattern with 2k ( if we are shifting k bits ).the most-significant bit is lost, and a 0 bit is inserted on the other end(if the number has no sign bit) 12a = 8： 0000 0000 0000 0000 0000 0000 0000 1000a &lt;&lt; 3：0000 0000 0000 0000 0000 0000 0100 0000 the order of bitwise operation in Python operator precedence（from highest to lowest) ~x x&lt;&lt;y，x&gt;&gt;y x&amp;y x^y x|y 按位或 common problems about bitwise operations: x &amp; (x - 1) used to erase the last bit of Xto understand x &amp; (x - 1), we should understand x-1 first.it means for x, set 0 to the position where the first 1 appears from the right to the left; set 1 to the all 0 after that position. application: Using O (1) time to detect whether the integer n is the power of 2that is to say, if n is the power of 2. It must greateror equal than 1 and it only have one bit is 1. 1234567def checkPowerOfTwo(n): if n &lt;= 0: return False if n &amp; (n-1) == 0: return True else: return False to find how many bits are 1 for a number 123456def checkHowManyOne(n): num = 0 while n: n = n&amp;(n-1) num+=1 return num compute the hamming distance of a and b. (how many bits we need to change from a to b) 123456789101112def hammingDistance(x, y): \"\"\" :type x: int :type y: int :rtype: int \"\"\" xor = x ^ y num = 0 while xor: xor = xor &amp; (xor -1) num += 1 return num to check whether a bit of number is 1 12# set the number a, and the index of the bit we intend to check is ba &amp; 1&lt;&lt; b (the execution priority of &lt;&lt; is higher ) application: Given a set of distinct integers, nums, return all possible subsets (the power set). （the question can also use backtracking too)123456789101112class Solution: def subsets(self, nums): res = [] for i in range(1&lt;&lt;len(nums)): tmp = [] # a certain bit is 1 or not for j in range(len(nums)): if i &amp; (1 &lt;&lt; j): tmp.append(nums[j]) res.append(tmp) return res a ^ b ^ b = a123456to prove it: a ^ b b -&gt; a 0 (same) 0 0 0 (same) 1 1 1（diff) 0 1 1（diff) 1 0 application: Can be used to encrypt In the array, only one number appears once, and the rest appear twice, find the number that appears once. Because there is only one number appears once while others appear twice which can elminate by XOR 123456def findAppearOnce(nums): n = len(nums) ret = nums[0] for i in range(1,n): ret = ret ^ nums[i] return ret common operations Function example bit operation Remove the last digit (101101 - &gt; 10110) x &gt;&gt; 1 Add a 0 (101101 - &gt; 1011010) x &lt;&lt; 1 Add a 1 (101101 - &gt; 1011011) x &lt;&lt; 1 + 1 at the end Change the last bit to 1 (101100 - &gt; 101101) x | 1 Change the last bit to 0 (101101 - &gt; 101100) x | 1-1 The last bit is inverted (101101 - &gt; 101100) x ^ 1 Change the k-th bit from right to 1 (101001 - &gt; 101101, k = 3) x | (1 &lt;&lt; (k-1)) Change the k-th bit of the right number to 0 (101101 - &gt; 101001, k = 3) X &amp; ~(1 &lt;&lt; (k-1)) Negate The k-th digit of number from right (101001 - &gt; 101101, k = 3) x ^ (1 &gt;&gt; (k-1)) only keep the last three digits (1101101 - &gt; 101) x &amp; 7 keep the last K digits (1101101 - &gt; 1101, k = 5) x &amp; ( (1 &gt;&gt; k)-1) Take the k-th digit (1101101 - &gt; 1, k = 4) x &gt;&gt; (k-1) &amp; 1 Change the kth bit to last to 1 (101001 - &gt; 101111, k = 4) x | (1 &gt;&gt; k-1) negate the kth bit to last (101001 - &gt; 100110, k = 4) x ^ (1 &lt;&lt; k-1) Change the continuous 1 on the right side to 0 (100101111 - &gt; 100100000) x &amp; (x + 1) Change the first 0 from the right to 1 (100101111 - &gt; 100111111) x | (x + 1) Change the continuous 0 on the right into 1 (11011000 - &gt; 11011111) x or (x-1) Take the continuous 1 (100101111 - &gt; 1111) (x ^ (x + 1))&gt;&gt; 1 Remove the left side of the last 1 to the last (100101000 - &gt; 1000) x &amp; (x ^ (x-1))","link":"/2020/05/27/bit-manipulation-in-python/"},{"title":"regular expression in python","text":"The materials are mainly based on https://deerchao.cn/tutorials/regex/regex.htm the online toolhttps://regex101.com/ basic knowledge of regular expression###Quantifiers||||-|-||A*| A sequence of zero or more ‘A’||A+| A sequence of one or more ‘A’||A?| A sequence of one or zero ‘A’||A{2}| A sequence of exactly two ‘A’}||A{2,5}| A sequence of two through five (inclusive) ‘A’||A{2,}| A sequence of two or more ‘A’| Metacharacters . Any single character ^ Match the beginning of a string $ Match the end of a string ^foobar$ A string that consists exactly of the word ‘foobar’ \\ Quote the next metacharacter \\ $ A ‘$’ [] Character class [0-9] A number between ‘0’ and ‘9’ [a-f] A lower case letter between ‘a’ and ‘f’ [G-Z] An upper case letter between ‘G’ and ‘Z’ [^a-z] Any character except characters between ‘a’ and ‘z’ [0-9a-zA-Z-] A hyphen or an alphanumeric character \\w match letters or numbers or underscores or Chines characters \\s matches any whitespace \\d match numbers \\b start or end of matching words \\W match any characters that are not letters, numbers, underscores or Chinese characters \\S matches any character that is not a space character \\D match any non numeric character \\B matching is not at the beginning or end of a word \\A Matches if the specified characters are at the start of a string the difference between ^$ vs \\b^Find the start of a line, $find the end of a line (without setting singleline)\\b match the beginning and end of a word (boundary) branch conditionsuse | to meet branch conditions. That is to say,There are several rules. If any one of them is satisfied, it should be regarded as a match\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8} This expression matches the phone number of the 3-digit area code, where the area code can be enclosed in parentheses or not used. The area code and the local number can be separated by hyphens or spaces, or there can be no interval. You can try to extend this expression to also support 4-bit area code by using branching conditions. group(): it was mainly used for repeating multiple characters(\\d {1,3} .) {3} \\d {1,3} is a simple IP address matching expression. To understand this expression, analyze it in the following order: \\d {1,3} matches 1 to 3 digits, (\\d {1,3} .) {3} matches 3 digits plus an English period (the whole group is the group) three times, and finally adds a one to three digits (\\d{1,3}) backreferenceAfter specifying a subexpression with parentheses, the text matching the subexpression (that is, the content captured by this grouping) can be further processed in the expression. By default, each group will automatically have a group number. The rule is: from left to right, the group number of the first group is 1, the second group is 2, and so on. Backward references are used to repeatedly search for text that matches a previous group. For example, \\1 represents the text matched by group 1. capture expression meaning (exp) match exp and capture text into an automatically named group (?exp) match exp, and capture the text to the group named name, or write (? ‘name’exp) (?: exp) match exp, do not capture matching text, and do not assign group number to this group Zero-width assertionThe next four are used to find something before or after something (but not including it), that is, they are used to specify a location like \\b, ^, $, which should meet certain conditions (i.e. assertions), so they are also called zero width assertions expression meaning (?= exp) match the position in front of exp (? &lt; = exp) match position after exp (?! exp) match is not followed by exp (? &lt;! exp) matches positions that are not exp before \\b\\w+(?=ing\\b):Matches the front part of a word ending in ing (except for ing), such as I’m singing while you’re dancing. It matches sing and danc (?&lt;=\\bre)\\w+\\b will match the second half of the word beginning with re (except for re), for example, when looking for reading a book, it will match ading. \\d{3}(?!\\d)Match three digits, and the three digits cannot be followed by a number (?&lt;![a-z])\\d{7}:Match seven digits that are not preceded by lowercase letters. comment(?#comment) Greed and laziness *? repeat any time, but as few as possible +? repeat once or more, but as little as possible ?? Repeat 0 or 1 time, but as little as possible {n, m}? Repeat n to m times, but as little as possible {n,}? Repeat more than n times, but as few as possible how to implement regular expression in python re module (built-in) expression meaning findall: Returns a list containing all matches search: Returns a Match object if there is a match anywhere in the string split Returns a list where the string has been split at each match sub Replaces one or many matches with a string re.findall(pattern, string) 1234567891011# Program to extract numbers from a stringimport restring = 'hello 12 hi 89. Howdy 34'pattern = '\\d+'result = re.findall(pattern, string)print(result)# Output: ['12', '89', '34'] when findall meets group(): 123456import restring = \"1--3--4-5--6--7\"pattern = \"([-]*)([0-9]+)\"result = re.findall(pattern,string)print(result)# Output: [('', '1'), ('--', '3'), ('--', '4'), ('-', '5'), ('--', '6'), ('--', '7')] re.split(pattern, string,[maxsplit])maxsplit:maximum number of splits that will occur 12345678910import restring = 'Twelve:12 Eighty nine:89 Nine:9.'pattern = '\\d+'# maxsplit = 1# split only at the first occurrenceresult = re.split(pattern, string, 1)print(result) re.sub() 1234567891011121314151617# Program to remove all whitespacesimport re# multiline stringstring = 'abc 12\\de 23 \\n f45 6'# matches all whitespace characterspattern = '\\s+'# empty stringreplace = ''new_string = re.sub(pattern, replace, string)print(new_string)# Output: abc12de23f456 re.subn()The re.subn() is similar to re.sub() expect it returns a tuple of 2 items containing the new string and the number of substitutions made. re.search(pattern, str) 123456import retxt = \"The rain in Spain\"x = re.search(\"\\s\", txt)print(\"The first white-space character is located in position:\", x.start()) search will return Match obejct match.group()The group() method returns the part of the string where there is a match. match.start()The start() function returns the index of the start of the matched substring match.end()end() returns the end index of the matched substring. match.span()function returns a tuple containing start and end index of the matched part. match.stringreturns the string passed into the function no need use re.compile","link":"/2020/06/10/regular-expression-in-python/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"bit manipulation","slug":"bit-manipulation","link":"/tags/bit-manipulation/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"regular expression","slug":"regular-expression","link":"/tags/regular-expression/"}],"categories":[{"name":"technology","slug":"technology","link":"/categories/technology/"}]}